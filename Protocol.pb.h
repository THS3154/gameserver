// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C_CHAT;
struct C_CHATDefaultTypeInternal;
extern C_CHATDefaultTypeInternal _C_CHAT_default_instance_;
class C_CREATECHARACTER;
struct C_CREATECHARACTERDefaultTypeInternal;
extern C_CREATECHARACTERDefaultTypeInternal _C_CREATECHARACTER_default_instance_;
class C_DUNJEON;
struct C_DUNJEONDefaultTypeInternal;
extern C_DUNJEONDefaultTypeInternal _C_DUNJEON_default_instance_;
class C_ENTER_GAME;
struct C_ENTER_GAMEDefaultTypeInternal;
extern C_ENTER_GAMEDefaultTypeInternal _C_ENTER_GAME_default_instance_;
class C_GAINEXP;
struct C_GAINEXPDefaultTypeInternal;
extern C_GAINEXPDefaultTypeInternal _C_GAINEXP_default_instance_;
class C_LEAVE_GAME;
struct C_LEAVE_GAMEDefaultTypeInternal;
extern C_LEAVE_GAMEDefaultTypeInternal _C_LEAVE_GAME_default_instance_;
class C_LEVEL_MOVE;
struct C_LEVEL_MOVEDefaultTypeInternal;
extern C_LEVEL_MOVEDefaultTypeInternal _C_LEVEL_MOVE_default_instance_;
class C_LEVEL_MOVE_COMPLETE;
struct C_LEVEL_MOVE_COMPLETEDefaultTypeInternal;
extern C_LEVEL_MOVE_COMPLETEDefaultTypeInternal _C_LEVEL_MOVE_COMPLETE_default_instance_;
class C_LOADEQUIPMENT;
struct C_LOADEQUIPMENTDefaultTypeInternal;
extern C_LOADEQUIPMENTDefaultTypeInternal _C_LOADEQUIPMENT_default_instance_;
class C_LOADINVENTORY;
struct C_LOADINVENTORYDefaultTypeInternal;
extern C_LOADINVENTORYDefaultTypeInternal _C_LOADINVENTORY_default_instance_;
class C_LOGIN;
struct C_LOGINDefaultTypeInternal;
extern C_LOGINDefaultTypeInternal _C_LOGIN_default_instance_;
class C_MOVE;
struct C_MOVEDefaultTypeInternal;
extern C_MOVEDefaultTypeInternal _C_MOVE_default_instance_;
class C_PING;
struct C_PINGDefaultTypeInternal;
extern C_PINGDefaultTypeInternal _C_PING_default_instance_;
class C_SKILL;
struct C_SKILLDefaultTypeInternal;
extern C_SKILLDefaultTypeInternal _C_SKILL_default_instance_;
class C_SPAWN_RESERVE;
struct C_SPAWN_RESERVEDefaultTypeInternal;
extern C_SPAWN_RESERVEDefaultTypeInternal _C_SPAWN_RESERVE_default_instance_;
class C_USEINVENTORY;
struct C_USEINVENTORYDefaultTypeInternal;
extern C_USEINVENTORYDefaultTypeInternal _C_USEINVENTORY_default_instance_;
class S_CHAT;
struct S_CHATDefaultTypeInternal;
extern S_CHATDefaultTypeInternal _S_CHAT_default_instance_;
class S_CREATECHARACTER;
struct S_CREATECHARACTERDefaultTypeInternal;
extern S_CREATECHARACTERDefaultTypeInternal _S_CREATECHARACTER_default_instance_;
class S_DESPAWN;
struct S_DESPAWNDefaultTypeInternal;
extern S_DESPAWNDefaultTypeInternal _S_DESPAWN_default_instance_;
class S_DUNJEON;
struct S_DUNJEONDefaultTypeInternal;
extern S_DUNJEONDefaultTypeInternal _S_DUNJEON_default_instance_;
class S_ENTER_GAME;
struct S_ENTER_GAMEDefaultTypeInternal;
extern S_ENTER_GAMEDefaultTypeInternal _S_ENTER_GAME_default_instance_;
class S_GAINEXP;
struct S_GAINEXPDefaultTypeInternal;
extern S_GAINEXPDefaultTypeInternal _S_GAINEXP_default_instance_;
class S_GAINGOLD;
struct S_GAINGOLDDefaultTypeInternal;
extern S_GAINGOLDDefaultTypeInternal _S_GAINGOLD_default_instance_;
class S_LEAVE_GAME;
struct S_LEAVE_GAMEDefaultTypeInternal;
extern S_LEAVE_GAMEDefaultTypeInternal _S_LEAVE_GAME_default_instance_;
class S_LEVEL_MOVE;
struct S_LEVEL_MOVEDefaultTypeInternal;
extern S_LEVEL_MOVEDefaultTypeInternal _S_LEVEL_MOVE_default_instance_;
class S_LEVEL_MOVE_COMPLETE;
struct S_LEVEL_MOVE_COMPLETEDefaultTypeInternal;
extern S_LEVEL_MOVE_COMPLETEDefaultTypeInternal _S_LEVEL_MOVE_COMPLETE_default_instance_;
class S_LOADEQUIPMENT;
struct S_LOADEQUIPMENTDefaultTypeInternal;
extern S_LOADEQUIPMENTDefaultTypeInternal _S_LOADEQUIPMENT_default_instance_;
class S_LOADINVENTORY;
struct S_LOADINVENTORYDefaultTypeInternal;
extern S_LOADINVENTORYDefaultTypeInternal _S_LOADINVENTORY_default_instance_;
class S_LOGIN;
struct S_LOGINDefaultTypeInternal;
extern S_LOGINDefaultTypeInternal _S_LOGIN_default_instance_;
class S_MOVE;
struct S_MOVEDefaultTypeInternal;
extern S_MOVEDefaultTypeInternal _S_MOVE_default_instance_;
class S_MOVES;
struct S_MOVESDefaultTypeInternal;
extern S_MOVESDefaultTypeInternal _S_MOVES_default_instance_;
class S_PING;
struct S_PINGDefaultTypeInternal;
extern S_PINGDefaultTypeInternal _S_PING_default_instance_;
class S_SKILL;
struct S_SKILLDefaultTypeInternal;
extern S_SKILLDefaultTypeInternal _S_SKILL_default_instance_;
class S_SPAWN;
struct S_SPAWNDefaultTypeInternal;
extern S_SPAWNDefaultTypeInternal _S_SPAWN_default_instance_;
class S_USEINVENTORY;
struct S_USEINVENTORYDefaultTypeInternal;
extern S_USEINVENTORYDefaultTypeInternal _S_USEINVENTORY_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_CHAT* Arena::CreateMaybeMessage<::Protocol::C_CHAT>(Arena*);
template<> ::Protocol::C_CREATECHARACTER* Arena::CreateMaybeMessage<::Protocol::C_CREATECHARACTER>(Arena*);
template<> ::Protocol::C_DUNJEON* Arena::CreateMaybeMessage<::Protocol::C_DUNJEON>(Arena*);
template<> ::Protocol::C_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::C_ENTER_GAME>(Arena*);
template<> ::Protocol::C_GAINEXP* Arena::CreateMaybeMessage<::Protocol::C_GAINEXP>(Arena*);
template<> ::Protocol::C_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::C_LEAVE_GAME>(Arena*);
template<> ::Protocol::C_LEVEL_MOVE* Arena::CreateMaybeMessage<::Protocol::C_LEVEL_MOVE>(Arena*);
template<> ::Protocol::C_LEVEL_MOVE_COMPLETE* Arena::CreateMaybeMessage<::Protocol::C_LEVEL_MOVE_COMPLETE>(Arena*);
template<> ::Protocol::C_LOADEQUIPMENT* Arena::CreateMaybeMessage<::Protocol::C_LOADEQUIPMENT>(Arena*);
template<> ::Protocol::C_LOADINVENTORY* Arena::CreateMaybeMessage<::Protocol::C_LOADINVENTORY>(Arena*);
template<> ::Protocol::C_LOGIN* Arena::CreateMaybeMessage<::Protocol::C_LOGIN>(Arena*);
template<> ::Protocol::C_MOVE* Arena::CreateMaybeMessage<::Protocol::C_MOVE>(Arena*);
template<> ::Protocol::C_PING* Arena::CreateMaybeMessage<::Protocol::C_PING>(Arena*);
template<> ::Protocol::C_SKILL* Arena::CreateMaybeMessage<::Protocol::C_SKILL>(Arena*);
template<> ::Protocol::C_SPAWN_RESERVE* Arena::CreateMaybeMessage<::Protocol::C_SPAWN_RESERVE>(Arena*);
template<> ::Protocol::C_USEINVENTORY* Arena::CreateMaybeMessage<::Protocol::C_USEINVENTORY>(Arena*);
template<> ::Protocol::S_CHAT* Arena::CreateMaybeMessage<::Protocol::S_CHAT>(Arena*);
template<> ::Protocol::S_CREATECHARACTER* Arena::CreateMaybeMessage<::Protocol::S_CREATECHARACTER>(Arena*);
template<> ::Protocol::S_DESPAWN* Arena::CreateMaybeMessage<::Protocol::S_DESPAWN>(Arena*);
template<> ::Protocol::S_DUNJEON* Arena::CreateMaybeMessage<::Protocol::S_DUNJEON>(Arena*);
template<> ::Protocol::S_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::S_ENTER_GAME>(Arena*);
template<> ::Protocol::S_GAINEXP* Arena::CreateMaybeMessage<::Protocol::S_GAINEXP>(Arena*);
template<> ::Protocol::S_GAINGOLD* Arena::CreateMaybeMessage<::Protocol::S_GAINGOLD>(Arena*);
template<> ::Protocol::S_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::S_LEAVE_GAME>(Arena*);
template<> ::Protocol::S_LEVEL_MOVE* Arena::CreateMaybeMessage<::Protocol::S_LEVEL_MOVE>(Arena*);
template<> ::Protocol::S_LEVEL_MOVE_COMPLETE* Arena::CreateMaybeMessage<::Protocol::S_LEVEL_MOVE_COMPLETE>(Arena*);
template<> ::Protocol::S_LOADEQUIPMENT* Arena::CreateMaybeMessage<::Protocol::S_LOADEQUIPMENT>(Arena*);
template<> ::Protocol::S_LOADINVENTORY* Arena::CreateMaybeMessage<::Protocol::S_LOADINVENTORY>(Arena*);
template<> ::Protocol::S_LOGIN* Arena::CreateMaybeMessage<::Protocol::S_LOGIN>(Arena*);
template<> ::Protocol::S_MOVE* Arena::CreateMaybeMessage<::Protocol::S_MOVE>(Arena*);
template<> ::Protocol::S_MOVES* Arena::CreateMaybeMessage<::Protocol::S_MOVES>(Arena*);
template<> ::Protocol::S_PING* Arena::CreateMaybeMessage<::Protocol::S_PING>(Arena*);
template<> ::Protocol::S_SKILL* Arena::CreateMaybeMessage<::Protocol::S_SKILL>(Arena*);
template<> ::Protocol::S_SPAWN* Arena::CreateMaybeMessage<::Protocol::S_SPAWN>(Arena*);
template<> ::Protocol::S_USEINVENTORY* Arena::CreateMaybeMessage<::Protocol::S_USEINVENTORY>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class C_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LOGIN) */ {
 public:
  inline C_LOGIN() : C_LOGIN(nullptr) {}
  ~C_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR C_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LOGIN(const C_LOGIN& from);
  C_LOGIN(C_LOGIN&& from) noexcept
    : C_LOGIN() {
    *this = ::std::move(from);
  }

  inline C_LOGIN& operator=(const C_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LOGIN& operator=(C_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LOGIN* internal_default_instance() {
    return reinterpret_cast<const C_LOGIN*>(
               &_C_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_LOGIN& a, C_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_LOGIN& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LOGIN";
  }
  protected:
  explicit C_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPwFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string pw = 2;
  void clear_pw();
  const std::string& pw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pw();
  PROTOBUF_NODISCARD std::string* release_pw();
  void set_allocated_pw(std::string* pw);
  private:
  const std::string& _internal_pw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pw(const std::string& value);
  std::string* _internal_mutable_pw();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LOGIN) */ {
 public:
  inline S_LOGIN() : S_LOGIN(nullptr) {}
  ~S_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR S_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LOGIN(const S_LOGIN& from);
  S_LOGIN(S_LOGIN&& from) noexcept
    : S_LOGIN() {
    *this = ::std::move(from);
  }

  inline S_LOGIN& operator=(const S_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LOGIN& operator=(S_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LOGIN* internal_default_instance() {
    return reinterpret_cast<const S_LOGIN*>(
               &_S_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_LOGIN& a, S_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_LOGIN& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LOGIN";
  }
  protected:
  explicit S_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectinfosFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kErrortypeFieldNumber = 3,
    kDbidFieldNumber = 4,
  };
  // repeated .Protocol.ObjectInfo objectinfos = 2;
  int objectinfos_size() const;
  private:
  int _internal_objectinfos_size() const;
  public:
  void clear_objectinfos();
  ::Protocol::ObjectInfo* mutable_objectinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
      mutable_objectinfos();
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfos(int index) const;
  ::Protocol::ObjectInfo* _internal_add_objectinfos();
  public:
  const ::Protocol::ObjectInfo& objectinfos(int index) const;
  ::Protocol::ObjectInfo* add_objectinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
      objectinfos() const;

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // .Protocol.LoginMessage errortype = 3;
  void clear_errortype();
  ::Protocol::LoginMessage errortype() const;
  void set_errortype(::Protocol::LoginMessage value);
  private:
  ::Protocol::LoginMessage _internal_errortype() const;
  void _internal_set_errortype(::Protocol::LoginMessage value);
  public:

  // uint64 dbid = 4;
  void clear_dbid();
  uint64_t dbid() const;
  void set_dbid(uint64_t value);
  private:
  uint64_t _internal_dbid() const;
  void _internal_set_dbid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo > objectinfos_;
  bool success_;
  int errortype_;
  uint64_t dbid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CREATECHARACTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CREATECHARACTER) */ {
 public:
  inline C_CREATECHARACTER() : C_CREATECHARACTER(nullptr) {}
  ~C_CREATECHARACTER() override;
  explicit PROTOBUF_CONSTEXPR C_CREATECHARACTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CREATECHARACTER(const C_CREATECHARACTER& from);
  C_CREATECHARACTER(C_CREATECHARACTER&& from) noexcept
    : C_CREATECHARACTER() {
    *this = ::std::move(from);
  }

  inline C_CREATECHARACTER& operator=(const C_CREATECHARACTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CREATECHARACTER& operator=(C_CREATECHARACTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CREATECHARACTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CREATECHARACTER* internal_default_instance() {
    return reinterpret_cast<const C_CREATECHARACTER*>(
               &_C_CREATECHARACTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(C_CREATECHARACTER& a, C_CREATECHARACTER& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CREATECHARACTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CREATECHARACTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CREATECHARACTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CREATECHARACTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CREATECHARACTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_CREATECHARACTER& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CREATECHARACTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CREATECHARACTER";
  }
  protected:
  explicit C_CREATECHARACTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Protocol.PlayerType type = 2;
  void clear_type();
  ::Protocol::PlayerType type() const;
  void set_type(::Protocol::PlayerType value);
  private:
  ::Protocol::PlayerType _internal_type() const;
  void _internal_set_type(::Protocol::PlayerType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CREATECHARACTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CREATECHARACTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CREATECHARACTER) */ {
 public:
  inline S_CREATECHARACTER() : S_CREATECHARACTER(nullptr) {}
  ~S_CREATECHARACTER() override;
  explicit PROTOBUF_CONSTEXPR S_CREATECHARACTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CREATECHARACTER(const S_CREATECHARACTER& from);
  S_CREATECHARACTER(S_CREATECHARACTER&& from) noexcept
    : S_CREATECHARACTER() {
    *this = ::std::move(from);
  }

  inline S_CREATECHARACTER& operator=(const S_CREATECHARACTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CREATECHARACTER& operator=(S_CREATECHARACTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CREATECHARACTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CREATECHARACTER* internal_default_instance() {
    return reinterpret_cast<const S_CREATECHARACTER*>(
               &_S_CREATECHARACTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_CREATECHARACTER& a, S_CREATECHARACTER& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CREATECHARACTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CREATECHARACTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CREATECHARACTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CREATECHARACTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CREATECHARACTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_CREATECHARACTER& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CREATECHARACTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CREATECHARACTER";
  }
  protected:
  explicit S_CREATECHARACTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectinfoFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // .Protocol.ObjectInfo objectinfo = 3;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // .Protocol.CreateCharacterMessage message = 2;
  void clear_message();
  ::Protocol::CreateCharacterMessage message() const;
  void set_message(::Protocol::CreateCharacterMessage value);
  private:
  ::Protocol::CreateCharacterMessage _internal_message() const;
  void _internal_set_message(::Protocol::CreateCharacterMessage value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CREATECHARACTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* objectinfo_;
  bool success_;
  int message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ENTER_GAME) */ {
 public:
  inline C_ENTER_GAME() : C_ENTER_GAME(nullptr) {}
  ~C_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR C_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ENTER_GAME(const C_ENTER_GAME& from);
  C_ENTER_GAME(C_ENTER_GAME&& from) noexcept
    : C_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline C_ENTER_GAME& operator=(const C_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ENTER_GAME& operator=(C_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const C_ENTER_GAME*>(
               &_C_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_ENTER_GAME& a, C_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_ENTER_GAME& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ENTER_GAME";
  }
  protected:
  explicit C_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIndexFieldNumber = 1,
    kLeveltypeFieldNumber = 2,
  };
  // uint64 playerIndex = 1;
  void clear_playerindex();
  uint64_t playerindex() const;
  void set_playerindex(uint64_t value);
  private:
  uint64_t _internal_playerindex() const;
  void _internal_set_playerindex(uint64_t value);
  public:

  // .Protocol.LevelType leveltype = 2;
  void clear_leveltype();
  ::Protocol::LevelType leveltype() const;
  void set_leveltype(::Protocol::LevelType value);
  private:
  ::Protocol::LevelType _internal_leveltype() const;
  void _internal_set_leveltype(::Protocol::LevelType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t playerindex_;
  int leveltype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ENTER_GAME) */ {
 public:
  inline S_ENTER_GAME() : S_ENTER_GAME(nullptr) {}
  ~S_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR S_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENTER_GAME(const S_ENTER_GAME& from);
  S_ENTER_GAME(S_ENTER_GAME&& from) noexcept
    : S_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline S_ENTER_GAME& operator=(const S_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENTER_GAME& operator=(S_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const S_ENTER_GAME*>(
               &_S_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(S_ENTER_GAME& a, S_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_ENTER_GAME& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENTER_GAME";
  }
  protected:
  explicit S_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 3,
    kObjectinfoFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .Protocol.ItemData items = 3;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ItemData* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData >*
      mutable_items();
  private:
  const ::Protocol::ItemData& _internal_items(int index) const;
  ::Protocol::ItemData* _internal_add_items();
  public:
  const ::Protocol::ItemData& items(int index) const;
  ::Protocol::ItemData* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData >&
      items() const;

  // .Protocol.ObjectInfo objectinfo = 2;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData > items_;
  ::Protocol::ObjectInfo* objectinfo_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LOADINVENTORY final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_LOADINVENTORY) */ {
 public:
  inline C_LOADINVENTORY() : C_LOADINVENTORY(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_LOADINVENTORY(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LOADINVENTORY(const C_LOADINVENTORY& from);
  C_LOADINVENTORY(C_LOADINVENTORY&& from) noexcept
    : C_LOADINVENTORY() {
    *this = ::std::move(from);
  }

  inline C_LOADINVENTORY& operator=(const C_LOADINVENTORY& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LOADINVENTORY& operator=(C_LOADINVENTORY&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LOADINVENTORY& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LOADINVENTORY* internal_default_instance() {
    return reinterpret_cast<const C_LOADINVENTORY*>(
               &_C_LOADINVENTORY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(C_LOADINVENTORY& a, C_LOADINVENTORY& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LOADINVENTORY* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LOADINVENTORY* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LOADINVENTORY* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LOADINVENTORY>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_LOADINVENTORY& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_LOADINVENTORY& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LOADINVENTORY";
  }
  protected:
  explicit C_LOADINVENTORY(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_LOADINVENTORY)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LOADINVENTORY final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LOADINVENTORY) */ {
 public:
  inline S_LOADINVENTORY() : S_LOADINVENTORY(nullptr) {}
  ~S_LOADINVENTORY() override;
  explicit PROTOBUF_CONSTEXPR S_LOADINVENTORY(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LOADINVENTORY(const S_LOADINVENTORY& from);
  S_LOADINVENTORY(S_LOADINVENTORY&& from) noexcept
    : S_LOADINVENTORY() {
    *this = ::std::move(from);
  }

  inline S_LOADINVENTORY& operator=(const S_LOADINVENTORY& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LOADINVENTORY& operator=(S_LOADINVENTORY&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LOADINVENTORY& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LOADINVENTORY* internal_default_instance() {
    return reinterpret_cast<const S_LOADINVENTORY*>(
               &_S_LOADINVENTORY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(S_LOADINVENTORY& a, S_LOADINVENTORY& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LOADINVENTORY* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LOADINVENTORY* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LOADINVENTORY* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LOADINVENTORY>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LOADINVENTORY& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_LOADINVENTORY& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LOADINVENTORY* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LOADINVENTORY";
  }
  protected:
  explicit S_LOADINVENTORY(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .Protocol.ItemData items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ItemData* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData >*
      mutable_items();
  private:
  const ::Protocol::ItemData& _internal_items(int index) const;
  ::Protocol::ItemData* _internal_add_items();
  public:
  const ::Protocol::ItemData& items(int index) const;
  ::Protocol::ItemData* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData >&
      items() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_LOADINVENTORY)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LOADEQUIPMENT final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_LOADEQUIPMENT) */ {
 public:
  inline C_LOADEQUIPMENT() : C_LOADEQUIPMENT(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_LOADEQUIPMENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LOADEQUIPMENT(const C_LOADEQUIPMENT& from);
  C_LOADEQUIPMENT(C_LOADEQUIPMENT&& from) noexcept
    : C_LOADEQUIPMENT() {
    *this = ::std::move(from);
  }

  inline C_LOADEQUIPMENT& operator=(const C_LOADEQUIPMENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LOADEQUIPMENT& operator=(C_LOADEQUIPMENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LOADEQUIPMENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LOADEQUIPMENT* internal_default_instance() {
    return reinterpret_cast<const C_LOADEQUIPMENT*>(
               &_C_LOADEQUIPMENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(C_LOADEQUIPMENT& a, C_LOADEQUIPMENT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LOADEQUIPMENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LOADEQUIPMENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LOADEQUIPMENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LOADEQUIPMENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_LOADEQUIPMENT& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_LOADEQUIPMENT& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LOADEQUIPMENT";
  }
  protected:
  explicit C_LOADEQUIPMENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_LOADEQUIPMENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LOADEQUIPMENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LOADEQUIPMENT) */ {
 public:
  inline S_LOADEQUIPMENT() : S_LOADEQUIPMENT(nullptr) {}
  ~S_LOADEQUIPMENT() override;
  explicit PROTOBUF_CONSTEXPR S_LOADEQUIPMENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LOADEQUIPMENT(const S_LOADEQUIPMENT& from);
  S_LOADEQUIPMENT(S_LOADEQUIPMENT&& from) noexcept
    : S_LOADEQUIPMENT() {
    *this = ::std::move(from);
  }

  inline S_LOADEQUIPMENT& operator=(const S_LOADEQUIPMENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LOADEQUIPMENT& operator=(S_LOADEQUIPMENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LOADEQUIPMENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LOADEQUIPMENT* internal_default_instance() {
    return reinterpret_cast<const S_LOADEQUIPMENT*>(
               &_S_LOADEQUIPMENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(S_LOADEQUIPMENT& a, S_LOADEQUIPMENT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LOADEQUIPMENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LOADEQUIPMENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LOADEQUIPMENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LOADEQUIPMENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LOADEQUIPMENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_LOADEQUIPMENT& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LOADEQUIPMENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LOADEQUIPMENT";
  }
  protected:
  explicit S_LOADEQUIPMENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kObjectinfoFieldNumber = 1,
  };
  // repeated .Protocol.ItemData items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ItemData* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData >*
      mutable_items();
  private:
  const ::Protocol::ItemData& _internal_items(int index) const;
  ::Protocol::ItemData* _internal_add_items();
  public:
  const ::Protocol::ItemData& items(int index) const;
  ::Protocol::ItemData* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData >&
      items() const;

  // .Protocol.ObjectInfo objectinfo = 1;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // @@protoc_insertion_point(class_scope:Protocol.S_LOADEQUIPMENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData > items_;
  ::Protocol::ObjectInfo* objectinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_USEINVENTORY final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_USEINVENTORY) */ {
 public:
  inline C_USEINVENTORY() : C_USEINVENTORY(nullptr) {}
  ~C_USEINVENTORY() override;
  explicit PROTOBUF_CONSTEXPR C_USEINVENTORY(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_USEINVENTORY(const C_USEINVENTORY& from);
  C_USEINVENTORY(C_USEINVENTORY&& from) noexcept
    : C_USEINVENTORY() {
    *this = ::std::move(from);
  }

  inline C_USEINVENTORY& operator=(const C_USEINVENTORY& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_USEINVENTORY& operator=(C_USEINVENTORY&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_USEINVENTORY& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_USEINVENTORY* internal_default_instance() {
    return reinterpret_cast<const C_USEINVENTORY*>(
               &_C_USEINVENTORY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(C_USEINVENTORY& a, C_USEINVENTORY& b) {
    a.Swap(&b);
  }
  inline void Swap(C_USEINVENTORY* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_USEINVENTORY* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_USEINVENTORY* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_USEINVENTORY>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_USEINVENTORY& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_USEINVENTORY& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_USEINVENTORY* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_USEINVENTORY";
  }
  protected:
  explicit C_USEINVENTORY(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceIdFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // uint64 instance_id = 1;
  void clear_instance_id();
  uint64_t instance_id() const;
  void set_instance_id(uint64_t value);
  private:
  uint64_t _internal_instance_id() const;
  void _internal_set_instance_id(uint64_t value);
  public:

  // uint64 code = 2;
  void clear_code();
  uint64_t code() const;
  void set_code(uint64_t value);
  private:
  uint64_t _internal_code() const;
  void _internal_set_code(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_USEINVENTORY)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t instance_id_;
  uint64_t code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_USEINVENTORY final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_USEINVENTORY) */ {
 public:
  inline S_USEINVENTORY() : S_USEINVENTORY(nullptr) {}
  ~S_USEINVENTORY() override;
  explicit PROTOBUF_CONSTEXPR S_USEINVENTORY(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_USEINVENTORY(const S_USEINVENTORY& from);
  S_USEINVENTORY(S_USEINVENTORY&& from) noexcept
    : S_USEINVENTORY() {
    *this = ::std::move(from);
  }

  inline S_USEINVENTORY& operator=(const S_USEINVENTORY& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_USEINVENTORY& operator=(S_USEINVENTORY&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_USEINVENTORY& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_USEINVENTORY* internal_default_instance() {
    return reinterpret_cast<const S_USEINVENTORY*>(
               &_S_USEINVENTORY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S_USEINVENTORY& a, S_USEINVENTORY& b) {
    a.Swap(&b);
  }
  inline void Swap(S_USEINVENTORY* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_USEINVENTORY* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_USEINVENTORY* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_USEINVENTORY>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_USEINVENTORY& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_USEINVENTORY& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_USEINVENTORY* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_USEINVENTORY";
  }
  protected:
  explicit S_USEINVENTORY(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectinfoFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // .Protocol.ObjectInfo objectinfo = 1;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // uint64 code = 2;
  void clear_code();
  uint64_t code() const;
  void set_code(uint64_t value);
  private:
  uint64_t _internal_code() const;
  void _internal_set_code(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_USEINVENTORY)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* objectinfo_;
  uint64_t code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LEAVE_GAME) */ {
 public:
  inline C_LEAVE_GAME() : C_LEAVE_GAME(nullptr) {}
  ~C_LEAVE_GAME() override;
  explicit PROTOBUF_CONSTEXPR C_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LEAVE_GAME(const C_LEAVE_GAME& from);
  C_LEAVE_GAME(C_LEAVE_GAME&& from) noexcept
    : C_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline C_LEAVE_GAME& operator=(const C_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LEAVE_GAME& operator=(C_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const C_LEAVE_GAME*>(
               &_C_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(C_LEAVE_GAME& a, C_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LEAVE_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LEAVE_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LEAVE_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_LEAVE_GAME& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LEAVE_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LEAVE_GAME";
  }
  protected:
  explicit C_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectinfoFieldNumber = 1,
  };
  // .Protocol.ObjectInfo objectinfo = 1;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // @@protoc_insertion_point(class_scope:Protocol.C_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* objectinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_LEAVE_GAME) */ {
 public:
  inline S_LEAVE_GAME() : S_LEAVE_GAME(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LEAVE_GAME(const S_LEAVE_GAME& from);
  S_LEAVE_GAME(S_LEAVE_GAME&& from) noexcept
    : S_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline S_LEAVE_GAME& operator=(const S_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LEAVE_GAME& operator=(S_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const S_LEAVE_GAME*>(
               &_S_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(S_LEAVE_GAME& a, S_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LEAVE_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LEAVE_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LEAVE_GAME";
  }
  protected:
  explicit S_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SPAWN_RESERVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SPAWN_RESERVE) */ {
 public:
  inline C_SPAWN_RESERVE() : C_SPAWN_RESERVE(nullptr) {}
  ~C_SPAWN_RESERVE() override;
  explicit PROTOBUF_CONSTEXPR C_SPAWN_RESERVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SPAWN_RESERVE(const C_SPAWN_RESERVE& from);
  C_SPAWN_RESERVE(C_SPAWN_RESERVE&& from) noexcept
    : C_SPAWN_RESERVE() {
    *this = ::std::move(from);
  }

  inline C_SPAWN_RESERVE& operator=(const C_SPAWN_RESERVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SPAWN_RESERVE& operator=(C_SPAWN_RESERVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SPAWN_RESERVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SPAWN_RESERVE* internal_default_instance() {
    return reinterpret_cast<const C_SPAWN_RESERVE*>(
               &_C_SPAWN_RESERVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(C_SPAWN_RESERVE& a, C_SPAWN_RESERVE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SPAWN_RESERVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SPAWN_RESERVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SPAWN_RESERVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SPAWN_RESERVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SPAWN_RESERVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_SPAWN_RESERVE& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SPAWN_RESERVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SPAWN_RESERVE";
  }
  protected:
  explicit C_SPAWN_RESERVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpawnerNameFieldNumber = 1,
    kObjectinfoFieldNumber = 2,
  };
  // string spawner_name = 1;
  void clear_spawner_name();
  const std::string& spawner_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spawner_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spawner_name();
  PROTOBUF_NODISCARD std::string* release_spawner_name();
  void set_allocated_spawner_name(std::string* spawner_name);
  private:
  const std::string& _internal_spawner_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spawner_name(const std::string& value);
  std::string* _internal_mutable_spawner_name();
  public:

  // .Protocol.ObjectInfo objectinfo = 2;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // @@protoc_insertion_point(class_scope:Protocol.C_SPAWN_RESERVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spawner_name_;
  ::Protocol::ObjectInfo* objectinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SPAWN) */ {
 public:
  inline S_SPAWN() : S_SPAWN(nullptr) {}
  ~S_SPAWN() override;
  explicit PROTOBUF_CONSTEXPR S_SPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SPAWN(const S_SPAWN& from);
  S_SPAWN(S_SPAWN&& from) noexcept
    : S_SPAWN() {
    *this = ::std::move(from);
  }

  inline S_SPAWN& operator=(const S_SPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SPAWN& operator=(S_SPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SPAWN* internal_default_instance() {
    return reinterpret_cast<const S_SPAWN*>(
               &_S_SPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(S_SPAWN& a, S_SPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_SPAWN& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SPAWN";
  }
  protected:
  explicit S_SPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectinfosFieldNumber = 1,
  };
  // repeated .Protocol.ObjectInfo objectinfos = 1;
  int objectinfos_size() const;
  private:
  int _internal_objectinfos_size() const;
  public:
  void clear_objectinfos();
  ::Protocol::ObjectInfo* mutable_objectinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
      mutable_objectinfos();
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfos(int index) const;
  ::Protocol::ObjectInfo* _internal_add_objectinfos();
  public:
  const ::Protocol::ObjectInfo& objectinfos(int index) const;
  ::Protocol::ObjectInfo* add_objectinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
      objectinfos() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_SPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo > objectinfos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DESPAWN) */ {
 public:
  inline S_DESPAWN() : S_DESPAWN(nullptr) {}
  ~S_DESPAWN() override;
  explicit PROTOBUF_CONSTEXPR S_DESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DESPAWN(const S_DESPAWN& from);
  S_DESPAWN(S_DESPAWN&& from) noexcept
    : S_DESPAWN() {
    *this = ::std::move(from);
  }

  inline S_DESPAWN& operator=(const S_DESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DESPAWN& operator=(S_DESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DESPAWN* internal_default_instance() {
    return reinterpret_cast<const S_DESPAWN*>(
               &_S_DESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(S_DESPAWN& a, S_DESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DESPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DESPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DESPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_DESPAWN& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DESPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DESPAWN";
  }
  protected:
  explicit S_DESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDespawnsFieldNumber = 1,
  };
  // repeated .Protocol.DespawnList despawns = 1;
  int despawns_size() const;
  private:
  int _internal_despawns_size() const;
  public:
  void clear_despawns();
  ::Protocol::DespawnList* mutable_despawns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::DespawnList >*
      mutable_despawns();
  private:
  const ::Protocol::DespawnList& _internal_despawns(int index) const;
  ::Protocol::DespawnList* _internal_add_despawns();
  public:
  const ::Protocol::DespawnList& despawns(int index) const;
  ::Protocol::DespawnList* add_despawns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::DespawnList >&
      despawns() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_DESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::DespawnList > despawns_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_MOVE) */ {
 public:
  inline C_MOVE() : C_MOVE(nullptr) {}
  ~C_MOVE() override;
  explicit PROTOBUF_CONSTEXPR C_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MOVE(const C_MOVE& from);
  C_MOVE(C_MOVE&& from) noexcept
    : C_MOVE() {
    *this = ::std::move(from);
  }

  inline C_MOVE& operator=(const C_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MOVE& operator=(C_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MOVE* internal_default_instance() {
    return reinterpret_cast<const C_MOVE*>(
               &_C_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(C_MOVE& a, C_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_MOVE& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_MOVE";
  }
  protected:
  explicit C_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosinfoFieldNumber = 1,
  };
  // .Protocol.PosInfo posinfo = 1;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PosInfo& posinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_posinfo();
  ::Protocol::PosInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PosInfo* posinfo);
  private:
  const ::Protocol::PosInfo& _internal_posinfo() const;
  ::Protocol::PosInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PosInfo* posinfo);
  ::Protocol::PosInfo* unsafe_arena_release_posinfo();

  // @@protoc_insertion_point(class_scope:Protocol.C_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::PosInfo* posinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MOVE) */ {
 public:
  inline S_MOVE() : S_MOVE(nullptr) {}
  ~S_MOVE() override;
  explicit PROTOBUF_CONSTEXPR S_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MOVE(const S_MOVE& from);
  S_MOVE(S_MOVE&& from) noexcept
    : S_MOVE() {
    *this = ::std::move(from);
  }

  inline S_MOVE& operator=(const S_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MOVE& operator=(S_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MOVE* internal_default_instance() {
    return reinterpret_cast<const S_MOVE*>(
               &_S_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(S_MOVE& a, S_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_MOVE& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MOVE";
  }
  protected:
  explicit S_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosinfoFieldNumber = 1,
  };
  // .Protocol.PosInfo posinfo = 1;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PosInfo& posinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_posinfo();
  ::Protocol::PosInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PosInfo* posinfo);
  private:
  const ::Protocol::PosInfo& _internal_posinfo() const;
  ::Protocol::PosInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PosInfo* posinfo);
  ::Protocol::PosInfo* unsafe_arena_release_posinfo();

  // @@protoc_insertion_point(class_scope:Protocol.S_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::PosInfo* posinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MOVES final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MOVES) */ {
 public:
  inline S_MOVES() : S_MOVES(nullptr) {}
  ~S_MOVES() override;
  explicit PROTOBUF_CONSTEXPR S_MOVES(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MOVES(const S_MOVES& from);
  S_MOVES(S_MOVES&& from) noexcept
    : S_MOVES() {
    *this = ::std::move(from);
  }

  inline S_MOVES& operator=(const S_MOVES& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MOVES& operator=(S_MOVES&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MOVES& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MOVES* internal_default_instance() {
    return reinterpret_cast<const S_MOVES*>(
               &_S_MOVES_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(S_MOVES& a, S_MOVES& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MOVES* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MOVES* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MOVES* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MOVES>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MOVES& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_MOVES& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MOVES* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MOVES";
  }
  protected:
  explicit S_MOVES(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosinfoFieldNumber = 1,
  };
  // repeated .Protocol.PosInfo posinfo = 1;
  int posinfo_size() const;
  private:
  int _internal_posinfo_size() const;
  public:
  void clear_posinfo();
  ::Protocol::PosInfo* mutable_posinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo >*
      mutable_posinfo();
  private:
  const ::Protocol::PosInfo& _internal_posinfo(int index) const;
  ::Protocol::PosInfo* _internal_add_posinfo();
  public:
  const ::Protocol::PosInfo& posinfo(int index) const;
  ::Protocol::PosInfo* add_posinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo >&
      posinfo() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_MOVES)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo > posinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LEVEL_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LEVEL_MOVE) */ {
 public:
  inline C_LEVEL_MOVE() : C_LEVEL_MOVE(nullptr) {}
  ~C_LEVEL_MOVE() override;
  explicit PROTOBUF_CONSTEXPR C_LEVEL_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LEVEL_MOVE(const C_LEVEL_MOVE& from);
  C_LEVEL_MOVE(C_LEVEL_MOVE&& from) noexcept
    : C_LEVEL_MOVE() {
    *this = ::std::move(from);
  }

  inline C_LEVEL_MOVE& operator=(const C_LEVEL_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LEVEL_MOVE& operator=(C_LEVEL_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LEVEL_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LEVEL_MOVE* internal_default_instance() {
    return reinterpret_cast<const C_LEVEL_MOVE*>(
               &_C_LEVEL_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(C_LEVEL_MOVE& a, C_LEVEL_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LEVEL_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LEVEL_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LEVEL_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LEVEL_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LEVEL_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_LEVEL_MOVE& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LEVEL_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LEVEL_MOVE";
  }
  protected:
  explicit C_LEVEL_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeveltypeFieldNumber = 1,
    kDestXFieldNumber = 2,
    kDestYFieldNumber = 3,
    kDestZFieldNumber = 4,
  };
  // .Protocol.LevelType leveltype = 1;
  void clear_leveltype();
  ::Protocol::LevelType leveltype() const;
  void set_leveltype(::Protocol::LevelType value);
  private:
  ::Protocol::LevelType _internal_leveltype() const;
  void _internal_set_leveltype(::Protocol::LevelType value);
  public:

  // float dest_x = 2;
  void clear_dest_x();
  float dest_x() const;
  void set_dest_x(float value);
  private:
  float _internal_dest_x() const;
  void _internal_set_dest_x(float value);
  public:

  // float dest_y = 3;
  void clear_dest_y();
  float dest_y() const;
  void set_dest_y(float value);
  private:
  float _internal_dest_y() const;
  void _internal_set_dest_y(float value);
  public:

  // float dest_z = 4;
  void clear_dest_z();
  float dest_z() const;
  void set_dest_z(float value);
  private:
  float _internal_dest_z() const;
  void _internal_set_dest_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_LEVEL_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int leveltype_;
  float dest_x_;
  float dest_y_;
  float dest_z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LEVEL_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LEVEL_MOVE) */ {
 public:
  inline S_LEVEL_MOVE() : S_LEVEL_MOVE(nullptr) {}
  ~S_LEVEL_MOVE() override;
  explicit PROTOBUF_CONSTEXPR S_LEVEL_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LEVEL_MOVE(const S_LEVEL_MOVE& from);
  S_LEVEL_MOVE(S_LEVEL_MOVE&& from) noexcept
    : S_LEVEL_MOVE() {
    *this = ::std::move(from);
  }

  inline S_LEVEL_MOVE& operator=(const S_LEVEL_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LEVEL_MOVE& operator=(S_LEVEL_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LEVEL_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LEVEL_MOVE* internal_default_instance() {
    return reinterpret_cast<const S_LEVEL_MOVE*>(
               &_S_LEVEL_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(S_LEVEL_MOVE& a, S_LEVEL_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LEVEL_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LEVEL_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LEVEL_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LEVEL_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LEVEL_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_LEVEL_MOVE& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LEVEL_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LEVEL_MOVE";
  }
  protected:
  explicit S_LEVEL_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelnameFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kLeveltypeFieldNumber = 3,
  };
  // string levelname = 2;
  void clear_levelname();
  const std::string& levelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_levelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_levelname();
  PROTOBUF_NODISCARD std::string* release_levelname();
  void set_allocated_levelname(std::string* levelname);
  private:
  const std::string& _internal_levelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_levelname(const std::string& value);
  std::string* _internal_mutable_levelname();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // .Protocol.LevelType leveltype = 3;
  void clear_leveltype();
  ::Protocol::LevelType leveltype() const;
  void set_leveltype(::Protocol::LevelType value);
  private:
  ::Protocol::LevelType _internal_leveltype() const;
  void _internal_set_leveltype(::Protocol::LevelType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LEVEL_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr levelname_;
  bool success_;
  int leveltype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LEVEL_MOVE_COMPLETE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LEVEL_MOVE_COMPLETE) */ {
 public:
  inline C_LEVEL_MOVE_COMPLETE() : C_LEVEL_MOVE_COMPLETE(nullptr) {}
  ~C_LEVEL_MOVE_COMPLETE() override;
  explicit PROTOBUF_CONSTEXPR C_LEVEL_MOVE_COMPLETE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LEVEL_MOVE_COMPLETE(const C_LEVEL_MOVE_COMPLETE& from);
  C_LEVEL_MOVE_COMPLETE(C_LEVEL_MOVE_COMPLETE&& from) noexcept
    : C_LEVEL_MOVE_COMPLETE() {
    *this = ::std::move(from);
  }

  inline C_LEVEL_MOVE_COMPLETE& operator=(const C_LEVEL_MOVE_COMPLETE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LEVEL_MOVE_COMPLETE& operator=(C_LEVEL_MOVE_COMPLETE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LEVEL_MOVE_COMPLETE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LEVEL_MOVE_COMPLETE* internal_default_instance() {
    return reinterpret_cast<const C_LEVEL_MOVE_COMPLETE*>(
               &_C_LEVEL_MOVE_COMPLETE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(C_LEVEL_MOVE_COMPLETE& a, C_LEVEL_MOVE_COMPLETE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LEVEL_MOVE_COMPLETE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LEVEL_MOVE_COMPLETE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LEVEL_MOVE_COMPLETE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LEVEL_MOVE_COMPLETE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LEVEL_MOVE_COMPLETE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_LEVEL_MOVE_COMPLETE& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LEVEL_MOVE_COMPLETE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LEVEL_MOVE_COMPLETE";
  }
  protected:
  explicit C_LEVEL_MOVE_COMPLETE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosinfoFieldNumber = 2,
    kLeveltypeFieldNumber = 1,
  };
  // .Protocol.PosInfo posinfo = 2;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PosInfo& posinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_posinfo();
  ::Protocol::PosInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PosInfo* posinfo);
  private:
  const ::Protocol::PosInfo& _internal_posinfo() const;
  ::Protocol::PosInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PosInfo* posinfo);
  ::Protocol::PosInfo* unsafe_arena_release_posinfo();

  // .Protocol.LevelType leveltype = 1;
  void clear_leveltype();
  ::Protocol::LevelType leveltype() const;
  void set_leveltype(::Protocol::LevelType value);
  private:
  ::Protocol::LevelType _internal_leveltype() const;
  void _internal_set_leveltype(::Protocol::LevelType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_LEVEL_MOVE_COMPLETE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::PosInfo* posinfo_;
  int leveltype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LEVEL_MOVE_COMPLETE final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_LEVEL_MOVE_COMPLETE) */ {
 public:
  inline S_LEVEL_MOVE_COMPLETE() : S_LEVEL_MOVE_COMPLETE(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_LEVEL_MOVE_COMPLETE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LEVEL_MOVE_COMPLETE(const S_LEVEL_MOVE_COMPLETE& from);
  S_LEVEL_MOVE_COMPLETE(S_LEVEL_MOVE_COMPLETE&& from) noexcept
    : S_LEVEL_MOVE_COMPLETE() {
    *this = ::std::move(from);
  }

  inline S_LEVEL_MOVE_COMPLETE& operator=(const S_LEVEL_MOVE_COMPLETE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LEVEL_MOVE_COMPLETE& operator=(S_LEVEL_MOVE_COMPLETE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LEVEL_MOVE_COMPLETE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LEVEL_MOVE_COMPLETE* internal_default_instance() {
    return reinterpret_cast<const S_LEVEL_MOVE_COMPLETE*>(
               &_S_LEVEL_MOVE_COMPLETE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(S_LEVEL_MOVE_COMPLETE& a, S_LEVEL_MOVE_COMPLETE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LEVEL_MOVE_COMPLETE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LEVEL_MOVE_COMPLETE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LEVEL_MOVE_COMPLETE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LEVEL_MOVE_COMPLETE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_LEVEL_MOVE_COMPLETE& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_LEVEL_MOVE_COMPLETE& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LEVEL_MOVE_COMPLETE";
  }
  protected:
  explicit S_LEVEL_MOVE_COMPLETE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_LEVEL_MOVE_COMPLETE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CHAT) */ {
 public:
  inline C_CHAT() : C_CHAT(nullptr) {}
  ~C_CHAT() override;
  explicit PROTOBUF_CONSTEXPR C_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CHAT(const C_CHAT& from);
  C_CHAT(C_CHAT&& from) noexcept
    : C_CHAT() {
    *this = ::std::move(from);
  }

  inline C_CHAT& operator=(const C_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CHAT& operator=(C_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CHAT* internal_default_instance() {
    return reinterpret_cast<const C_CHAT*>(
               &_C_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(C_CHAT& a, C_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_CHAT& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CHAT";
  }
  protected:
  explicit C_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHAT) */ {
 public:
  inline S_CHAT() : S_CHAT(nullptr) {}
  ~S_CHAT() override;
  explicit PROTOBUF_CONSTEXPR S_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHAT(const S_CHAT& from);
  S_CHAT(S_CHAT&& from) noexcept
    : S_CHAT() {
    *this = ::std::move(from);
  }

  inline S_CHAT& operator=(const S_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHAT& operator=(S_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHAT* internal_default_instance() {
    return reinterpret_cast<const S_CHAT*>(
               &_S_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(S_CHAT& a, S_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_CHAT& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHAT";
  }
  protected:
  explicit S_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // uint64 playerId = 1;
  void clear_playerid();
  uint64_t playerid() const;
  void set_playerid(uint64_t value);
  private:
  uint64_t _internal_playerid() const;
  void _internal_set_playerid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  uint64_t playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SKILL) */ {
 public:
  inline C_SKILL() : C_SKILL(nullptr) {}
  ~C_SKILL() override;
  explicit PROTOBUF_CONSTEXPR C_SKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SKILL(const C_SKILL& from);
  C_SKILL(C_SKILL&& from) noexcept
    : C_SKILL() {
    *this = ::std::move(from);
  }

  inline C_SKILL& operator=(const C_SKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SKILL& operator=(C_SKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SKILL* internal_default_instance() {
    return reinterpret_cast<const C_SKILL*>(
               &_C_SKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(C_SKILL& a, C_SKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_SKILL& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SKILL";
  }
  protected:
  explicit C_SKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectinfoFieldNumber = 1,
    kTimestampFieldNumber = 3,
    kSkillIdFieldNumber = 2,
    kDirectionFieldNumber = 4,
  };
  // .Protocol.ObjectInfo objectinfo = 1;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // uint64 timestamp = 3;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // .Protocol.SkillID skill_id = 2;
  void clear_skill_id();
  ::Protocol::SkillID skill_id() const;
  void set_skill_id(::Protocol::SkillID value);
  private:
  ::Protocol::SkillID _internal_skill_id() const;
  void _internal_set_skill_id(::Protocol::SkillID value);
  public:

  // float direction = 4;
  void clear_direction();
  float direction() const;
  void set_direction(float value);
  private:
  float _internal_direction() const;
  void _internal_set_direction(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_SKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* objectinfo_;
  uint64_t timestamp_;
  int skill_id_;
  float direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SKILL) */ {
 public:
  inline S_SKILL() : S_SKILL(nullptr) {}
  ~S_SKILL() override;
  explicit PROTOBUF_CONSTEXPR S_SKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SKILL(const S_SKILL& from);
  S_SKILL(S_SKILL&& from) noexcept
    : S_SKILL() {
    *this = ::std::move(from);
  }

  inline S_SKILL& operator=(const S_SKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SKILL& operator=(S_SKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SKILL* internal_default_instance() {
    return reinterpret_cast<const S_SKILL*>(
               &_S_SKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(S_SKILL& a, S_SKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_SKILL& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SKILL";
  }
  protected:
  explicit S_SKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHitResultsFieldNumber = 3,
    kCasterIdFieldNumber = 1,
    kSkillIdFieldNumber = 2,
  };
  // repeated .Protocol.SkillHitResult hit_results = 3;
  int hit_results_size() const;
  private:
  int _internal_hit_results_size() const;
  public:
  void clear_hit_results();
  ::Protocol::SkillHitResult* mutable_hit_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::SkillHitResult >*
      mutable_hit_results();
  private:
  const ::Protocol::SkillHitResult& _internal_hit_results(int index) const;
  ::Protocol::SkillHitResult* _internal_add_hit_results();
  public:
  const ::Protocol::SkillHitResult& hit_results(int index) const;
  ::Protocol::SkillHitResult* add_hit_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::SkillHitResult >&
      hit_results() const;

  // uint64 caster_id = 1;
  void clear_caster_id();
  uint64_t caster_id() const;
  void set_caster_id(uint64_t value);
  private:
  uint64_t _internal_caster_id() const;
  void _internal_set_caster_id(uint64_t value);
  public:

  // .Protocol.SkillID skill_id = 2;
  void clear_skill_id();
  ::Protocol::SkillID skill_id() const;
  void set_skill_id(::Protocol::SkillID value);
  private:
  ::Protocol::SkillID _internal_skill_id() const;
  void _internal_set_skill_id(::Protocol::SkillID value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::SkillHitResult > hit_results_;
  uint64_t caster_id_;
  int skill_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_GAINEXP final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_GAINEXP) */ {
 public:
  inline C_GAINEXP() : C_GAINEXP(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_GAINEXP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_GAINEXP(const C_GAINEXP& from);
  C_GAINEXP(C_GAINEXP&& from) noexcept
    : C_GAINEXP() {
    *this = ::std::move(from);
  }

  inline C_GAINEXP& operator=(const C_GAINEXP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_GAINEXP& operator=(C_GAINEXP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_GAINEXP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_GAINEXP* internal_default_instance() {
    return reinterpret_cast<const C_GAINEXP*>(
               &_C_GAINEXP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(C_GAINEXP& a, C_GAINEXP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_GAINEXP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_GAINEXP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_GAINEXP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_GAINEXP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_GAINEXP& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_GAINEXP& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_GAINEXP";
  }
  protected:
  explicit C_GAINEXP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_GAINEXP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_GAINEXP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_GAINEXP) */ {
 public:
  inline S_GAINEXP() : S_GAINEXP(nullptr) {}
  ~S_GAINEXP() override;
  explicit PROTOBUF_CONSTEXPR S_GAINEXP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_GAINEXP(const S_GAINEXP& from);
  S_GAINEXP(S_GAINEXP&& from) noexcept
    : S_GAINEXP() {
    *this = ::std::move(from);
  }

  inline S_GAINEXP& operator=(const S_GAINEXP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_GAINEXP& operator=(S_GAINEXP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_GAINEXP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_GAINEXP* internal_default_instance() {
    return reinterpret_cast<const S_GAINEXP*>(
               &_S_GAINEXP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(S_GAINEXP& a, S_GAINEXP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_GAINEXP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_GAINEXP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_GAINEXP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_GAINEXP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_GAINEXP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_GAINEXP& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_GAINEXP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_GAINEXP";
  }
  protected:
  explicit S_GAINEXP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectinfoFieldNumber = 1,
  };
  // .Protocol.ObjectInfo objectinfo = 1;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // @@protoc_insertion_point(class_scope:Protocol.S_GAINEXP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* objectinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_GAINGOLD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_GAINGOLD) */ {
 public:
  inline S_GAINGOLD() : S_GAINGOLD(nullptr) {}
  ~S_GAINGOLD() override;
  explicit PROTOBUF_CONSTEXPR S_GAINGOLD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_GAINGOLD(const S_GAINGOLD& from);
  S_GAINGOLD(S_GAINGOLD&& from) noexcept
    : S_GAINGOLD() {
    *this = ::std::move(from);
  }

  inline S_GAINGOLD& operator=(const S_GAINGOLD& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_GAINGOLD& operator=(S_GAINGOLD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_GAINGOLD& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_GAINGOLD* internal_default_instance() {
    return reinterpret_cast<const S_GAINGOLD*>(
               &_S_GAINGOLD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(S_GAINGOLD& a, S_GAINGOLD& b) {
    a.Swap(&b);
  }
  inline void Swap(S_GAINGOLD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_GAINGOLD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_GAINGOLD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_GAINGOLD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_GAINGOLD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_GAINGOLD& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_GAINGOLD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_GAINGOLD";
  }
  protected:
  explicit S_GAINGOLD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectinfoFieldNumber = 1,
  };
  // .Protocol.ObjectInfo objectinfo = 1;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // @@protoc_insertion_point(class_scope:Protocol.S_GAINGOLD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* objectinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PING final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PING) */ {
 public:
  inline C_PING() : C_PING(nullptr) {}
  ~C_PING() override;
  explicit PROTOBUF_CONSTEXPR C_PING(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PING(const C_PING& from);
  C_PING(C_PING&& from) noexcept
    : C_PING() {
    *this = ::std::move(from);
  }

  inline C_PING& operator=(const C_PING& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PING& operator=(C_PING&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PING& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PING* internal_default_instance() {
    return reinterpret_cast<const C_PING*>(
               &_C_PING_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(C_PING& a, C_PING& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PING* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PING* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PING* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PING>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PING& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C_PING& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PING* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PING";
  }
  protected:
  explicit C_PING(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_PING)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PING final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PING) */ {
 public:
  inline S_PING() : S_PING(nullptr) {}
  ~S_PING() override;
  explicit PROTOBUF_CONSTEXPR S_PING(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PING(const S_PING& from);
  S_PING(S_PING&& from) noexcept
    : S_PING() {
    *this = ::std::move(from);
  }

  inline S_PING& operator=(const S_PING& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PING& operator=(S_PING&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PING& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PING* internal_default_instance() {
    return reinterpret_cast<const S_PING*>(
               &_S_PING_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(S_PING& a, S_PING& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PING* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PING* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PING* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PING>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PING& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_PING& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PING* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PING";
  }
  protected:
  explicit S_PING(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PING)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_DUNJEON final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_DUNJEON) */ {
 public:
  inline C_DUNJEON() : C_DUNJEON(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_DUNJEON(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_DUNJEON(const C_DUNJEON& from);
  C_DUNJEON(C_DUNJEON&& from) noexcept
    : C_DUNJEON() {
    *this = ::std::move(from);
  }

  inline C_DUNJEON& operator=(const C_DUNJEON& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_DUNJEON& operator=(C_DUNJEON&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_DUNJEON& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_DUNJEON* internal_default_instance() {
    return reinterpret_cast<const C_DUNJEON*>(
               &_C_DUNJEON_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(C_DUNJEON& a, C_DUNJEON& b) {
    a.Swap(&b);
  }
  inline void Swap(C_DUNJEON* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_DUNJEON* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_DUNJEON* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_DUNJEON>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_DUNJEON& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_DUNJEON& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_DUNJEON";
  }
  protected:
  explicit C_DUNJEON(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_DUNJEON)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DUNJEON final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DUNJEON) */ {
 public:
  inline S_DUNJEON() : S_DUNJEON(nullptr) {}
  ~S_DUNJEON() override;
  explicit PROTOBUF_CONSTEXPR S_DUNJEON(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DUNJEON(const S_DUNJEON& from);
  S_DUNJEON(S_DUNJEON&& from) noexcept
    : S_DUNJEON() {
    *this = ::std::move(from);
  }

  inline S_DUNJEON& operator=(const S_DUNJEON& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DUNJEON& operator=(S_DUNJEON&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DUNJEON& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DUNJEON* internal_default_instance() {
    return reinterpret_cast<const S_DUNJEON*>(
               &_S_DUNJEON_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(S_DUNJEON& a, S_DUNJEON& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DUNJEON* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DUNJEON* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DUNJEON* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DUNJEON>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DUNJEON& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_DUNJEON& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DUNJEON* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DUNJEON";
  }
  protected:
  explicit S_DUNJEON(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemaintimeFieldNumber = 1,
    kProgressFieldNumber = 2,
  };
  // uint64 remaintime = 1;
  void clear_remaintime();
  uint64_t remaintime() const;
  void set_remaintime(uint64_t value);
  private:
  uint64_t _internal_remaintime() const;
  void _internal_set_remaintime(uint64_t value);
  public:

  // float progress = 2;
  void clear_progress();
  float progress() const;
  void set_progress(float value);
  private:
  float _internal_progress() const;
  void _internal_set_progress(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_DUNJEON)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t remaintime_;
  float progress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_LOGIN

// string id = 1;
inline void C_LOGIN::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& C_LOGIN::id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LOGIN.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LOGIN::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_LOGIN.id)
}
inline std::string* C_LOGIN::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:Protocol.C_LOGIN.id)
  return _s;
}
inline const std::string& C_LOGIN::_internal_id() const {
  return id_.Get();
}
inline void C_LOGIN::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* C_LOGIN::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* C_LOGIN::release_id() {
  // @@protoc_insertion_point(field_release:Protocol.C_LOGIN.id)
  return id_.Release();
}
inline void C_LOGIN::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_LOGIN.id)
}

// string pw = 2;
inline void C_LOGIN::clear_pw() {
  pw_.ClearToEmpty();
}
inline const std::string& C_LOGIN::pw() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LOGIN.pw)
  return _internal_pw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LOGIN::set_pw(ArgT0&& arg0, ArgT... args) {
 
 pw_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_LOGIN.pw)
}
inline std::string* C_LOGIN::mutable_pw() {
  std::string* _s = _internal_mutable_pw();
  // @@protoc_insertion_point(field_mutable:Protocol.C_LOGIN.pw)
  return _s;
}
inline const std::string& C_LOGIN::_internal_pw() const {
  return pw_.Get();
}
inline void C_LOGIN::_internal_set_pw(const std::string& value) {
  
  pw_.Set(value, GetArenaForAllocation());
}
inline std::string* C_LOGIN::_internal_mutable_pw() {
  
  return pw_.Mutable(GetArenaForAllocation());
}
inline std::string* C_LOGIN::release_pw() {
  // @@protoc_insertion_point(field_release:Protocol.C_LOGIN.pw)
  return pw_.Release();
}
inline void C_LOGIN::set_allocated_pw(std::string* pw) {
  if (pw != nullptr) {
    
  } else {
    
  }
  pw_.SetAllocated(pw, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pw_.IsDefault()) {
    pw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_LOGIN.pw)
}

// -------------------------------------------------------------------

// S_LOGIN

// bool success = 1;
inline void S_LOGIN::clear_success() {
  success_ = false;
}
inline bool S_LOGIN::_internal_success() const {
  return success_;
}
inline bool S_LOGIN::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.success)
  return _internal_success();
}
inline void S_LOGIN::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_LOGIN::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOGIN.success)
}

// repeated .Protocol.ObjectInfo objectinfos = 2;
inline int S_LOGIN::_internal_objectinfos_size() const {
  return objectinfos_.size();
}
inline int S_LOGIN::objectinfos_size() const {
  return _internal_objectinfos_size();
}
inline ::Protocol::ObjectInfo* S_LOGIN::mutable_objectinfos(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_LOGIN.objectinfos)
  return objectinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
S_LOGIN::mutable_objectinfos() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_LOGIN.objectinfos)
  return &objectinfos_;
}
inline const ::Protocol::ObjectInfo& S_LOGIN::_internal_objectinfos(int index) const {
  return objectinfos_.Get(index);
}
inline const ::Protocol::ObjectInfo& S_LOGIN::objectinfos(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.objectinfos)
  return _internal_objectinfos(index);
}
inline ::Protocol::ObjectInfo* S_LOGIN::_internal_add_objectinfos() {
  return objectinfos_.Add();
}
inline ::Protocol::ObjectInfo* S_LOGIN::add_objectinfos() {
  ::Protocol::ObjectInfo* _add = _internal_add_objectinfos();
  // @@protoc_insertion_point(field_add:Protocol.S_LOGIN.objectinfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
S_LOGIN::objectinfos() const {
  // @@protoc_insertion_point(field_list:Protocol.S_LOGIN.objectinfos)
  return objectinfos_;
}

// .Protocol.LoginMessage errortype = 3;
inline void S_LOGIN::clear_errortype() {
  errortype_ = 0;
}
inline ::Protocol::LoginMessage S_LOGIN::_internal_errortype() const {
  return static_cast< ::Protocol::LoginMessage >(errortype_);
}
inline ::Protocol::LoginMessage S_LOGIN::errortype() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.errortype)
  return _internal_errortype();
}
inline void S_LOGIN::_internal_set_errortype(::Protocol::LoginMessage value) {
  
  errortype_ = value;
}
inline void S_LOGIN::set_errortype(::Protocol::LoginMessage value) {
  _internal_set_errortype(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOGIN.errortype)
}

// uint64 dbid = 4;
inline void S_LOGIN::clear_dbid() {
  dbid_ = uint64_t{0u};
}
inline uint64_t S_LOGIN::_internal_dbid() const {
  return dbid_;
}
inline uint64_t S_LOGIN::dbid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.dbid)
  return _internal_dbid();
}
inline void S_LOGIN::_internal_set_dbid(uint64_t value) {
  
  dbid_ = value;
}
inline void S_LOGIN::set_dbid(uint64_t value) {
  _internal_set_dbid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOGIN.dbid)
}

// -------------------------------------------------------------------

// C_CREATECHARACTER

// string name = 1;
inline void C_CREATECHARACTER::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& C_CREATECHARACTER::name() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CREATECHARACTER.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CREATECHARACTER::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CREATECHARACTER.name)
}
inline std::string* C_CREATECHARACTER::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CREATECHARACTER.name)
  return _s;
}
inline const std::string& C_CREATECHARACTER::_internal_name() const {
  return name_.Get();
}
inline void C_CREATECHARACTER::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CREATECHARACTER::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CREATECHARACTER::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.C_CREATECHARACTER.name)
  return name_.Release();
}
inline void C_CREATECHARACTER::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CREATECHARACTER.name)
}

// .Protocol.PlayerType type = 2;
inline void C_CREATECHARACTER::clear_type() {
  type_ = 0;
}
inline ::Protocol::PlayerType C_CREATECHARACTER::_internal_type() const {
  return static_cast< ::Protocol::PlayerType >(type_);
}
inline ::Protocol::PlayerType C_CREATECHARACTER::type() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CREATECHARACTER.type)
  return _internal_type();
}
inline void C_CREATECHARACTER::_internal_set_type(::Protocol::PlayerType value) {
  
  type_ = value;
}
inline void C_CREATECHARACTER::set_type(::Protocol::PlayerType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CREATECHARACTER.type)
}

// -------------------------------------------------------------------

// S_CREATECHARACTER

// bool success = 1;
inline void S_CREATECHARACTER::clear_success() {
  success_ = false;
}
inline bool S_CREATECHARACTER::_internal_success() const {
  return success_;
}
inline bool S_CREATECHARACTER::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CREATECHARACTER.success)
  return _internal_success();
}
inline void S_CREATECHARACTER::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_CREATECHARACTER::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CREATECHARACTER.success)
}

// .Protocol.CreateCharacterMessage message = 2;
inline void S_CREATECHARACTER::clear_message() {
  message_ = 0;
}
inline ::Protocol::CreateCharacterMessage S_CREATECHARACTER::_internal_message() const {
  return static_cast< ::Protocol::CreateCharacterMessage >(message_);
}
inline ::Protocol::CreateCharacterMessage S_CREATECHARACTER::message() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CREATECHARACTER.message)
  return _internal_message();
}
inline void S_CREATECHARACTER::_internal_set_message(::Protocol::CreateCharacterMessage value) {
  
  message_ = value;
}
inline void S_CREATECHARACTER::set_message(::Protocol::CreateCharacterMessage value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CREATECHARACTER.message)
}

// .Protocol.ObjectInfo objectinfo = 3;
inline bool S_CREATECHARACTER::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool S_CREATECHARACTER::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& S_CREATECHARACTER::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_CREATECHARACTER::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CREATECHARACTER.objectinfo)
  return _internal_objectinfo();
}
inline void S_CREATECHARACTER::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_CREATECHARACTER.objectinfo)
}
inline ::Protocol::ObjectInfo* S_CREATECHARACTER::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_CREATECHARACTER::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_CREATECHARACTER.objectinfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_CREATECHARACTER::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* S_CREATECHARACTER::mutable_objectinfo() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_objectinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CREATECHARACTER.objectinfo)
  return _msg;
}
inline void S_CREATECHARACTER::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CREATECHARACTER.objectinfo)
}

// -------------------------------------------------------------------

// C_ENTER_GAME

// uint64 playerIndex = 1;
inline void C_ENTER_GAME::clear_playerindex() {
  playerindex_ = uint64_t{0u};
}
inline uint64_t C_ENTER_GAME::_internal_playerindex() const {
  return playerindex_;
}
inline uint64_t C_ENTER_GAME::playerindex() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER_GAME.playerIndex)
  return _internal_playerindex();
}
inline void C_ENTER_GAME::_internal_set_playerindex(uint64_t value) {
  
  playerindex_ = value;
}
inline void C_ENTER_GAME::set_playerindex(uint64_t value) {
  _internal_set_playerindex(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER_GAME.playerIndex)
}

// .Protocol.LevelType leveltype = 2;
inline void C_ENTER_GAME::clear_leveltype() {
  leveltype_ = 0;
}
inline ::Protocol::LevelType C_ENTER_GAME::_internal_leveltype() const {
  return static_cast< ::Protocol::LevelType >(leveltype_);
}
inline ::Protocol::LevelType C_ENTER_GAME::leveltype() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER_GAME.leveltype)
  return _internal_leveltype();
}
inline void C_ENTER_GAME::_internal_set_leveltype(::Protocol::LevelType value) {
  
  leveltype_ = value;
}
inline void C_ENTER_GAME::set_leveltype(::Protocol::LevelType value) {
  _internal_set_leveltype(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER_GAME.leveltype)
}

// -------------------------------------------------------------------

// S_ENTER_GAME

// bool success = 1;
inline void S_ENTER_GAME::clear_success() {
  success_ = false;
}
inline bool S_ENTER_GAME::_internal_success() const {
  return success_;
}
inline bool S_ENTER_GAME::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.success)
  return _internal_success();
}
inline void S_ENTER_GAME::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_ENTER_GAME::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ENTER_GAME.success)
}

// .Protocol.ObjectInfo objectinfo = 2;
inline bool S_ENTER_GAME::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool S_ENTER_GAME::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& S_ENTER_GAME::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_ENTER_GAME::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.objectinfo)
  return _internal_objectinfo();
}
inline void S_ENTER_GAME::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ENTER_GAME.objectinfo)
}
inline ::Protocol::ObjectInfo* S_ENTER_GAME::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_ENTER_GAME::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_ENTER_GAME.objectinfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_ENTER_GAME::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* S_ENTER_GAME::mutable_objectinfo() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_objectinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER_GAME.objectinfo)
  return _msg;
}
inline void S_ENTER_GAME::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ENTER_GAME.objectinfo)
}

// repeated .Protocol.ItemData items = 3;
inline int S_ENTER_GAME::_internal_items_size() const {
  return items_.size();
}
inline int S_ENTER_GAME::items_size() const {
  return _internal_items_size();
}
inline ::Protocol::ItemData* S_ENTER_GAME::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER_GAME.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData >*
S_ENTER_GAME::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_ENTER_GAME.items)
  return &items_;
}
inline const ::Protocol::ItemData& S_ENTER_GAME::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::Protocol::ItemData& S_ENTER_GAME::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.items)
  return _internal_items(index);
}
inline ::Protocol::ItemData* S_ENTER_GAME::_internal_add_items() {
  return items_.Add();
}
inline ::Protocol::ItemData* S_ENTER_GAME::add_items() {
  ::Protocol::ItemData* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.S_ENTER_GAME.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData >&
S_ENTER_GAME::items() const {
  // @@protoc_insertion_point(field_list:Protocol.S_ENTER_GAME.items)
  return items_;
}

// -------------------------------------------------------------------

// C_LOADINVENTORY

// -------------------------------------------------------------------

// S_LOADINVENTORY

// repeated .Protocol.ItemData items = 1;
inline int S_LOADINVENTORY::_internal_items_size() const {
  return items_.size();
}
inline int S_LOADINVENTORY::items_size() const {
  return _internal_items_size();
}
inline ::Protocol::ItemData* S_LOADINVENTORY::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_LOADINVENTORY.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData >*
S_LOADINVENTORY::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_LOADINVENTORY.items)
  return &items_;
}
inline const ::Protocol::ItemData& S_LOADINVENTORY::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::Protocol::ItemData& S_LOADINVENTORY::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOADINVENTORY.items)
  return _internal_items(index);
}
inline ::Protocol::ItemData* S_LOADINVENTORY::_internal_add_items() {
  return items_.Add();
}
inline ::Protocol::ItemData* S_LOADINVENTORY::add_items() {
  ::Protocol::ItemData* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.S_LOADINVENTORY.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData >&
S_LOADINVENTORY::items() const {
  // @@protoc_insertion_point(field_list:Protocol.S_LOADINVENTORY.items)
  return items_;
}

// -------------------------------------------------------------------

// C_LOADEQUIPMENT

// -------------------------------------------------------------------

// S_LOADEQUIPMENT

// .Protocol.ObjectInfo objectinfo = 1;
inline bool S_LOADEQUIPMENT::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool S_LOADEQUIPMENT::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& S_LOADEQUIPMENT::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_LOADEQUIPMENT::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOADEQUIPMENT.objectinfo)
  return _internal_objectinfo();
}
inline void S_LOADEQUIPMENT::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_LOADEQUIPMENT.objectinfo)
}
inline ::Protocol::ObjectInfo* S_LOADEQUIPMENT::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_LOADEQUIPMENT::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_LOADEQUIPMENT.objectinfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_LOADEQUIPMENT::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* S_LOADEQUIPMENT::mutable_objectinfo() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_objectinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_LOADEQUIPMENT.objectinfo)
  return _msg;
}
inline void S_LOADEQUIPMENT::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_LOADEQUIPMENT.objectinfo)
}

// repeated .Protocol.ItemData items = 2;
inline int S_LOADEQUIPMENT::_internal_items_size() const {
  return items_.size();
}
inline int S_LOADEQUIPMENT::items_size() const {
  return _internal_items_size();
}
inline ::Protocol::ItemData* S_LOADEQUIPMENT::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_LOADEQUIPMENT.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData >*
S_LOADEQUIPMENT::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_LOADEQUIPMENT.items)
  return &items_;
}
inline const ::Protocol::ItemData& S_LOADEQUIPMENT::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::Protocol::ItemData& S_LOADEQUIPMENT::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOADEQUIPMENT.items)
  return _internal_items(index);
}
inline ::Protocol::ItemData* S_LOADEQUIPMENT::_internal_add_items() {
  return items_.Add();
}
inline ::Protocol::ItemData* S_LOADEQUIPMENT::add_items() {
  ::Protocol::ItemData* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.S_LOADEQUIPMENT.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemData >&
S_LOADEQUIPMENT::items() const {
  // @@protoc_insertion_point(field_list:Protocol.S_LOADEQUIPMENT.items)
  return items_;
}

// -------------------------------------------------------------------

// C_USEINVENTORY

// uint64 instance_id = 1;
inline void C_USEINVENTORY::clear_instance_id() {
  instance_id_ = uint64_t{0u};
}
inline uint64_t C_USEINVENTORY::_internal_instance_id() const {
  return instance_id_;
}
inline uint64_t C_USEINVENTORY::instance_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_USEINVENTORY.instance_id)
  return _internal_instance_id();
}
inline void C_USEINVENTORY::_internal_set_instance_id(uint64_t value) {
  
  instance_id_ = value;
}
inline void C_USEINVENTORY::set_instance_id(uint64_t value) {
  _internal_set_instance_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_USEINVENTORY.instance_id)
}

// uint64 code = 2;
inline void C_USEINVENTORY::clear_code() {
  code_ = uint64_t{0u};
}
inline uint64_t C_USEINVENTORY::_internal_code() const {
  return code_;
}
inline uint64_t C_USEINVENTORY::code() const {
  // @@protoc_insertion_point(field_get:Protocol.C_USEINVENTORY.code)
  return _internal_code();
}
inline void C_USEINVENTORY::_internal_set_code(uint64_t value) {
  
  code_ = value;
}
inline void C_USEINVENTORY::set_code(uint64_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:Protocol.C_USEINVENTORY.code)
}

// -------------------------------------------------------------------

// S_USEINVENTORY

// .Protocol.ObjectInfo objectinfo = 1;
inline bool S_USEINVENTORY::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool S_USEINVENTORY::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& S_USEINVENTORY::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_USEINVENTORY::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_USEINVENTORY.objectinfo)
  return _internal_objectinfo();
}
inline void S_USEINVENTORY::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_USEINVENTORY.objectinfo)
}
inline ::Protocol::ObjectInfo* S_USEINVENTORY::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_USEINVENTORY::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_USEINVENTORY.objectinfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_USEINVENTORY::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* S_USEINVENTORY::mutable_objectinfo() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_objectinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_USEINVENTORY.objectinfo)
  return _msg;
}
inline void S_USEINVENTORY::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_USEINVENTORY.objectinfo)
}

// uint64 code = 2;
inline void S_USEINVENTORY::clear_code() {
  code_ = uint64_t{0u};
}
inline uint64_t S_USEINVENTORY::_internal_code() const {
  return code_;
}
inline uint64_t S_USEINVENTORY::code() const {
  // @@protoc_insertion_point(field_get:Protocol.S_USEINVENTORY.code)
  return _internal_code();
}
inline void S_USEINVENTORY::_internal_set_code(uint64_t value) {
  
  code_ = value;
}
inline void S_USEINVENTORY::set_code(uint64_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:Protocol.S_USEINVENTORY.code)
}

// -------------------------------------------------------------------

// C_LEAVE_GAME

// .Protocol.ObjectInfo objectinfo = 1;
inline bool C_LEAVE_GAME::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool C_LEAVE_GAME::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& C_LEAVE_GAME::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& C_LEAVE_GAME::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LEAVE_GAME.objectinfo)
  return _internal_objectinfo();
}
inline void C_LEAVE_GAME::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_LEAVE_GAME.objectinfo)
}
inline ::Protocol::ObjectInfo* C_LEAVE_GAME::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* C_LEAVE_GAME::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_LEAVE_GAME.objectinfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* C_LEAVE_GAME::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* C_LEAVE_GAME::mutable_objectinfo() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_objectinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.C_LEAVE_GAME.objectinfo)
  return _msg;
}
inline void C_LEAVE_GAME::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_LEAVE_GAME.objectinfo)
}

// -------------------------------------------------------------------

// S_LEAVE_GAME

// -------------------------------------------------------------------

// C_SPAWN_RESERVE

// string spawner_name = 1;
inline void C_SPAWN_RESERVE::clear_spawner_name() {
  spawner_name_.ClearToEmpty();
}
inline const std::string& C_SPAWN_RESERVE::spawner_name() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SPAWN_RESERVE.spawner_name)
  return _internal_spawner_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_SPAWN_RESERVE::set_spawner_name(ArgT0&& arg0, ArgT... args) {
 
 spawner_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_SPAWN_RESERVE.spawner_name)
}
inline std::string* C_SPAWN_RESERVE::mutable_spawner_name() {
  std::string* _s = _internal_mutable_spawner_name();
  // @@protoc_insertion_point(field_mutable:Protocol.C_SPAWN_RESERVE.spawner_name)
  return _s;
}
inline const std::string& C_SPAWN_RESERVE::_internal_spawner_name() const {
  return spawner_name_.Get();
}
inline void C_SPAWN_RESERVE::_internal_set_spawner_name(const std::string& value) {
  
  spawner_name_.Set(value, GetArenaForAllocation());
}
inline std::string* C_SPAWN_RESERVE::_internal_mutable_spawner_name() {
  
  return spawner_name_.Mutable(GetArenaForAllocation());
}
inline std::string* C_SPAWN_RESERVE::release_spawner_name() {
  // @@protoc_insertion_point(field_release:Protocol.C_SPAWN_RESERVE.spawner_name)
  return spawner_name_.Release();
}
inline void C_SPAWN_RESERVE::set_allocated_spawner_name(std::string* spawner_name) {
  if (spawner_name != nullptr) {
    
  } else {
    
  }
  spawner_name_.SetAllocated(spawner_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (spawner_name_.IsDefault()) {
    spawner_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_SPAWN_RESERVE.spawner_name)
}

// .Protocol.ObjectInfo objectinfo = 2;
inline bool C_SPAWN_RESERVE::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool C_SPAWN_RESERVE::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& C_SPAWN_RESERVE::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& C_SPAWN_RESERVE::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SPAWN_RESERVE.objectinfo)
  return _internal_objectinfo();
}
inline void C_SPAWN_RESERVE::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_SPAWN_RESERVE.objectinfo)
}
inline ::Protocol::ObjectInfo* C_SPAWN_RESERVE::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* C_SPAWN_RESERVE::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_SPAWN_RESERVE.objectinfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* C_SPAWN_RESERVE::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* C_SPAWN_RESERVE::mutable_objectinfo() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_objectinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.C_SPAWN_RESERVE.objectinfo)
  return _msg;
}
inline void C_SPAWN_RESERVE::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_SPAWN_RESERVE.objectinfo)
}

// -------------------------------------------------------------------

// S_SPAWN

// repeated .Protocol.ObjectInfo objectinfos = 1;
inline int S_SPAWN::_internal_objectinfos_size() const {
  return objectinfos_.size();
}
inline int S_SPAWN::objectinfos_size() const {
  return _internal_objectinfos_size();
}
inline ::Protocol::ObjectInfo* S_SPAWN::mutable_objectinfos(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWN.objectinfos)
  return objectinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
S_SPAWN::mutable_objectinfos() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWN.objectinfos)
  return &objectinfos_;
}
inline const ::Protocol::ObjectInfo& S_SPAWN::_internal_objectinfos(int index) const {
  return objectinfos_.Get(index);
}
inline const ::Protocol::ObjectInfo& S_SPAWN::objectinfos(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.objectinfos)
  return _internal_objectinfos(index);
}
inline ::Protocol::ObjectInfo* S_SPAWN::_internal_add_objectinfos() {
  return objectinfos_.Add();
}
inline ::Protocol::ObjectInfo* S_SPAWN::add_objectinfos() {
  ::Protocol::ObjectInfo* _add = _internal_add_objectinfos();
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWN.objectinfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
S_SPAWN::objectinfos() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWN.objectinfos)
  return objectinfos_;
}

// -------------------------------------------------------------------

// S_DESPAWN

// repeated .Protocol.DespawnList despawns = 1;
inline int S_DESPAWN::_internal_despawns_size() const {
  return despawns_.size();
}
inline int S_DESPAWN::despawns_size() const {
  return _internal_despawns_size();
}
inline ::Protocol::DespawnList* S_DESPAWN::mutable_despawns(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_DESPAWN.despawns)
  return despawns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::DespawnList >*
S_DESPAWN::mutable_despawns() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_DESPAWN.despawns)
  return &despawns_;
}
inline const ::Protocol::DespawnList& S_DESPAWN::_internal_despawns(int index) const {
  return despawns_.Get(index);
}
inline const ::Protocol::DespawnList& S_DESPAWN::despawns(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_DESPAWN.despawns)
  return _internal_despawns(index);
}
inline ::Protocol::DespawnList* S_DESPAWN::_internal_add_despawns() {
  return despawns_.Add();
}
inline ::Protocol::DespawnList* S_DESPAWN::add_despawns() {
  ::Protocol::DespawnList* _add = _internal_add_despawns();
  // @@protoc_insertion_point(field_add:Protocol.S_DESPAWN.despawns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::DespawnList >&
S_DESPAWN::despawns() const {
  // @@protoc_insertion_point(field_list:Protocol.S_DESPAWN.despawns)
  return despawns_;
}

// -------------------------------------------------------------------

// C_MOVE

// .Protocol.PosInfo posinfo = 1;
inline bool C_MOVE::_internal_has_posinfo() const {
  return this != internal_default_instance() && posinfo_ != nullptr;
}
inline bool C_MOVE::has_posinfo() const {
  return _internal_has_posinfo();
}
inline const ::Protocol::PosInfo& C_MOVE::_internal_posinfo() const {
  const ::Protocol::PosInfo* p = posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& C_MOVE::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MOVE.posinfo)
  return _internal_posinfo();
}
inline void C_MOVE::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PosInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_MOVE.posinfo)
}
inline ::Protocol::PosInfo* C_MOVE::release_posinfo() {
  
  ::Protocol::PosInfo* temp = posinfo_;
  posinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* C_MOVE::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_MOVE.posinfo)
  
  ::Protocol::PosInfo* temp = posinfo_;
  posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* C_MOVE::_internal_mutable_posinfo() {
  
  if (posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    posinfo_ = p;
  }
  return posinfo_;
}
inline ::Protocol::PosInfo* C_MOVE::mutable_posinfo() {
  ::Protocol::PosInfo* _msg = _internal_mutable_posinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.C_MOVE.posinfo)
  return _msg;
}
inline void C_MOVE::set_allocated_posinfo(::Protocol::PosInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo));
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_MOVE.posinfo)
}

// -------------------------------------------------------------------

// S_MOVE

// .Protocol.PosInfo posinfo = 1;
inline bool S_MOVE::_internal_has_posinfo() const {
  return this != internal_default_instance() && posinfo_ != nullptr;
}
inline bool S_MOVE::has_posinfo() const {
  return _internal_has_posinfo();
}
inline const ::Protocol::PosInfo& S_MOVE::_internal_posinfo() const {
  const ::Protocol::PosInfo* p = posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& S_MOVE::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVE.posinfo)
  return _internal_posinfo();
}
inline void S_MOVE::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PosInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_MOVE.posinfo)
}
inline ::Protocol::PosInfo* S_MOVE::release_posinfo() {
  
  ::Protocol::PosInfo* temp = posinfo_;
  posinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* S_MOVE::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_MOVE.posinfo)
  
  ::Protocol::PosInfo* temp = posinfo_;
  posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* S_MOVE::_internal_mutable_posinfo() {
  
  if (posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    posinfo_ = p;
  }
  return posinfo_;
}
inline ::Protocol::PosInfo* S_MOVE::mutable_posinfo() {
  ::Protocol::PosInfo* _msg = _internal_mutable_posinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_MOVE.posinfo)
  return _msg;
}
inline void S_MOVE::set_allocated_posinfo(::Protocol::PosInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo));
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_MOVE.posinfo)
}

// -------------------------------------------------------------------

// S_MOVES

// repeated .Protocol.PosInfo posinfo = 1;
inline int S_MOVES::_internal_posinfo_size() const {
  return posinfo_.size();
}
inline int S_MOVES::posinfo_size() const {
  return _internal_posinfo_size();
}
inline ::Protocol::PosInfo* S_MOVES::mutable_posinfo(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_MOVES.posinfo)
  return posinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo >*
S_MOVES::mutable_posinfo() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_MOVES.posinfo)
  return &posinfo_;
}
inline const ::Protocol::PosInfo& S_MOVES::_internal_posinfo(int index) const {
  return posinfo_.Get(index);
}
inline const ::Protocol::PosInfo& S_MOVES::posinfo(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVES.posinfo)
  return _internal_posinfo(index);
}
inline ::Protocol::PosInfo* S_MOVES::_internal_add_posinfo() {
  return posinfo_.Add();
}
inline ::Protocol::PosInfo* S_MOVES::add_posinfo() {
  ::Protocol::PosInfo* _add = _internal_add_posinfo();
  // @@protoc_insertion_point(field_add:Protocol.S_MOVES.posinfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo >&
S_MOVES::posinfo() const {
  // @@protoc_insertion_point(field_list:Protocol.S_MOVES.posinfo)
  return posinfo_;
}

// -------------------------------------------------------------------

// C_LEVEL_MOVE

// .Protocol.LevelType leveltype = 1;
inline void C_LEVEL_MOVE::clear_leveltype() {
  leveltype_ = 0;
}
inline ::Protocol::LevelType C_LEVEL_MOVE::_internal_leveltype() const {
  return static_cast< ::Protocol::LevelType >(leveltype_);
}
inline ::Protocol::LevelType C_LEVEL_MOVE::leveltype() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LEVEL_MOVE.leveltype)
  return _internal_leveltype();
}
inline void C_LEVEL_MOVE::_internal_set_leveltype(::Protocol::LevelType value) {
  
  leveltype_ = value;
}
inline void C_LEVEL_MOVE::set_leveltype(::Protocol::LevelType value) {
  _internal_set_leveltype(value);
  // @@protoc_insertion_point(field_set:Protocol.C_LEVEL_MOVE.leveltype)
}

// float dest_x = 2;
inline void C_LEVEL_MOVE::clear_dest_x() {
  dest_x_ = 0;
}
inline float C_LEVEL_MOVE::_internal_dest_x() const {
  return dest_x_;
}
inline float C_LEVEL_MOVE::dest_x() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LEVEL_MOVE.dest_x)
  return _internal_dest_x();
}
inline void C_LEVEL_MOVE::_internal_set_dest_x(float value) {
  
  dest_x_ = value;
}
inline void C_LEVEL_MOVE::set_dest_x(float value) {
  _internal_set_dest_x(value);
  // @@protoc_insertion_point(field_set:Protocol.C_LEVEL_MOVE.dest_x)
}

// float dest_y = 3;
inline void C_LEVEL_MOVE::clear_dest_y() {
  dest_y_ = 0;
}
inline float C_LEVEL_MOVE::_internal_dest_y() const {
  return dest_y_;
}
inline float C_LEVEL_MOVE::dest_y() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LEVEL_MOVE.dest_y)
  return _internal_dest_y();
}
inline void C_LEVEL_MOVE::_internal_set_dest_y(float value) {
  
  dest_y_ = value;
}
inline void C_LEVEL_MOVE::set_dest_y(float value) {
  _internal_set_dest_y(value);
  // @@protoc_insertion_point(field_set:Protocol.C_LEVEL_MOVE.dest_y)
}

// float dest_z = 4;
inline void C_LEVEL_MOVE::clear_dest_z() {
  dest_z_ = 0;
}
inline float C_LEVEL_MOVE::_internal_dest_z() const {
  return dest_z_;
}
inline float C_LEVEL_MOVE::dest_z() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LEVEL_MOVE.dest_z)
  return _internal_dest_z();
}
inline void C_LEVEL_MOVE::_internal_set_dest_z(float value) {
  
  dest_z_ = value;
}
inline void C_LEVEL_MOVE::set_dest_z(float value) {
  _internal_set_dest_z(value);
  // @@protoc_insertion_point(field_set:Protocol.C_LEVEL_MOVE.dest_z)
}

// -------------------------------------------------------------------

// S_LEVEL_MOVE

// bool success = 1;
inline void S_LEVEL_MOVE::clear_success() {
  success_ = false;
}
inline bool S_LEVEL_MOVE::_internal_success() const {
  return success_;
}
inline bool S_LEVEL_MOVE::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LEVEL_MOVE.success)
  return _internal_success();
}
inline void S_LEVEL_MOVE::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_LEVEL_MOVE::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LEVEL_MOVE.success)
}

// string levelname = 2;
inline void S_LEVEL_MOVE::clear_levelname() {
  levelname_.ClearToEmpty();
}
inline const std::string& S_LEVEL_MOVE::levelname() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LEVEL_MOVE.levelname)
  return _internal_levelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_LEVEL_MOVE::set_levelname(ArgT0&& arg0, ArgT... args) {
 
 levelname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_LEVEL_MOVE.levelname)
}
inline std::string* S_LEVEL_MOVE::mutable_levelname() {
  std::string* _s = _internal_mutable_levelname();
  // @@protoc_insertion_point(field_mutable:Protocol.S_LEVEL_MOVE.levelname)
  return _s;
}
inline const std::string& S_LEVEL_MOVE::_internal_levelname() const {
  return levelname_.Get();
}
inline void S_LEVEL_MOVE::_internal_set_levelname(const std::string& value) {
  
  levelname_.Set(value, GetArenaForAllocation());
}
inline std::string* S_LEVEL_MOVE::_internal_mutable_levelname() {
  
  return levelname_.Mutable(GetArenaForAllocation());
}
inline std::string* S_LEVEL_MOVE::release_levelname() {
  // @@protoc_insertion_point(field_release:Protocol.S_LEVEL_MOVE.levelname)
  return levelname_.Release();
}
inline void S_LEVEL_MOVE::set_allocated_levelname(std::string* levelname) {
  if (levelname != nullptr) {
    
  } else {
    
  }
  levelname_.SetAllocated(levelname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (levelname_.IsDefault()) {
    levelname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_LEVEL_MOVE.levelname)
}

// .Protocol.LevelType leveltype = 3;
inline void S_LEVEL_MOVE::clear_leveltype() {
  leveltype_ = 0;
}
inline ::Protocol::LevelType S_LEVEL_MOVE::_internal_leveltype() const {
  return static_cast< ::Protocol::LevelType >(leveltype_);
}
inline ::Protocol::LevelType S_LEVEL_MOVE::leveltype() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LEVEL_MOVE.leveltype)
  return _internal_leveltype();
}
inline void S_LEVEL_MOVE::_internal_set_leveltype(::Protocol::LevelType value) {
  
  leveltype_ = value;
}
inline void S_LEVEL_MOVE::set_leveltype(::Protocol::LevelType value) {
  _internal_set_leveltype(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LEVEL_MOVE.leveltype)
}

// -------------------------------------------------------------------

// C_LEVEL_MOVE_COMPLETE

// .Protocol.LevelType leveltype = 1;
inline void C_LEVEL_MOVE_COMPLETE::clear_leveltype() {
  leveltype_ = 0;
}
inline ::Protocol::LevelType C_LEVEL_MOVE_COMPLETE::_internal_leveltype() const {
  return static_cast< ::Protocol::LevelType >(leveltype_);
}
inline ::Protocol::LevelType C_LEVEL_MOVE_COMPLETE::leveltype() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LEVEL_MOVE_COMPLETE.leveltype)
  return _internal_leveltype();
}
inline void C_LEVEL_MOVE_COMPLETE::_internal_set_leveltype(::Protocol::LevelType value) {
  
  leveltype_ = value;
}
inline void C_LEVEL_MOVE_COMPLETE::set_leveltype(::Protocol::LevelType value) {
  _internal_set_leveltype(value);
  // @@protoc_insertion_point(field_set:Protocol.C_LEVEL_MOVE_COMPLETE.leveltype)
}

// .Protocol.PosInfo posinfo = 2;
inline bool C_LEVEL_MOVE_COMPLETE::_internal_has_posinfo() const {
  return this != internal_default_instance() && posinfo_ != nullptr;
}
inline bool C_LEVEL_MOVE_COMPLETE::has_posinfo() const {
  return _internal_has_posinfo();
}
inline const ::Protocol::PosInfo& C_LEVEL_MOVE_COMPLETE::_internal_posinfo() const {
  const ::Protocol::PosInfo* p = posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& C_LEVEL_MOVE_COMPLETE::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LEVEL_MOVE_COMPLETE.posinfo)
  return _internal_posinfo();
}
inline void C_LEVEL_MOVE_COMPLETE::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PosInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_LEVEL_MOVE_COMPLETE.posinfo)
}
inline ::Protocol::PosInfo* C_LEVEL_MOVE_COMPLETE::release_posinfo() {
  
  ::Protocol::PosInfo* temp = posinfo_;
  posinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* C_LEVEL_MOVE_COMPLETE::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_LEVEL_MOVE_COMPLETE.posinfo)
  
  ::Protocol::PosInfo* temp = posinfo_;
  posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* C_LEVEL_MOVE_COMPLETE::_internal_mutable_posinfo() {
  
  if (posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    posinfo_ = p;
  }
  return posinfo_;
}
inline ::Protocol::PosInfo* C_LEVEL_MOVE_COMPLETE::mutable_posinfo() {
  ::Protocol::PosInfo* _msg = _internal_mutable_posinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.C_LEVEL_MOVE_COMPLETE.posinfo)
  return _msg;
}
inline void C_LEVEL_MOVE_COMPLETE::set_allocated_posinfo(::Protocol::PosInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo));
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_LEVEL_MOVE_COMPLETE.posinfo)
}

// -------------------------------------------------------------------

// S_LEVEL_MOVE_COMPLETE

// -------------------------------------------------------------------

// C_CHAT

// string msg = 1;
inline void C_CHAT::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& C_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CHAT.msg)
}
inline std::string* C_CHAT::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CHAT.msg)
  return _s;
}
inline const std::string& C_CHAT::_internal_msg() const {
  return msg_.Get();
}
inline void C_CHAT::_internal_set_msg(const std::string& value) {
  
  msg_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CHAT::_internal_mutable_msg() {
  
  return msg_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.C_CHAT.msg)
  return msg_.Release();
}
inline void C_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault()) {
    msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CHAT.msg)
}

// -------------------------------------------------------------------

// S_CHAT

// uint64 playerId = 1;
inline void S_CHAT::clear_playerid() {
  playerid_ = uint64_t{0u};
}
inline uint64_t S_CHAT::_internal_playerid() const {
  return playerid_;
}
inline uint64_t S_CHAT::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.playerId)
  return _internal_playerid();
}
inline void S_CHAT::_internal_set_playerid(uint64_t value) {
  
  playerid_ = value;
}
inline void S_CHAT::set_playerid(uint64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.playerId)
}

// string msg = 2;
inline void S_CHAT::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& S_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.msg)
}
inline std::string* S_CHAT::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CHAT.msg)
  return _s;
}
inline const std::string& S_CHAT::_internal_msg() const {
  return msg_.Get();
}
inline void S_CHAT::_internal_set_msg(const std::string& value) {
  
  msg_.Set(value, GetArenaForAllocation());
}
inline std::string* S_CHAT::_internal_mutable_msg() {
  
  return msg_.Mutable(GetArenaForAllocation());
}
inline std::string* S_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.S_CHAT.msg)
  return msg_.Release();
}
inline void S_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault()) {
    msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CHAT.msg)
}

// -------------------------------------------------------------------

// C_SKILL

// .Protocol.ObjectInfo objectinfo = 1;
inline bool C_SKILL::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool C_SKILL::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& C_SKILL::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& C_SKILL::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SKILL.objectinfo)
  return _internal_objectinfo();
}
inline void C_SKILL::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_SKILL.objectinfo)
}
inline ::Protocol::ObjectInfo* C_SKILL::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* C_SKILL::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_SKILL.objectinfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* C_SKILL::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* C_SKILL::mutable_objectinfo() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_objectinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.C_SKILL.objectinfo)
  return _msg;
}
inline void C_SKILL::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_SKILL.objectinfo)
}

// .Protocol.SkillID skill_id = 2;
inline void C_SKILL::clear_skill_id() {
  skill_id_ = 0;
}
inline ::Protocol::SkillID C_SKILL::_internal_skill_id() const {
  return static_cast< ::Protocol::SkillID >(skill_id_);
}
inline ::Protocol::SkillID C_SKILL::skill_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SKILL.skill_id)
  return _internal_skill_id();
}
inline void C_SKILL::_internal_set_skill_id(::Protocol::SkillID value) {
  
  skill_id_ = value;
}
inline void C_SKILL::set_skill_id(::Protocol::SkillID value) {
  _internal_set_skill_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SKILL.skill_id)
}

// uint64 timestamp = 3;
inline void C_SKILL::clear_timestamp() {
  timestamp_ = uint64_t{0u};
}
inline uint64_t C_SKILL::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t C_SKILL::timestamp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SKILL.timestamp)
  return _internal_timestamp();
}
inline void C_SKILL::_internal_set_timestamp(uint64_t value) {
  
  timestamp_ = value;
}
inline void C_SKILL::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SKILL.timestamp)
}

// float direction = 4;
inline void C_SKILL::clear_direction() {
  direction_ = 0;
}
inline float C_SKILL::_internal_direction() const {
  return direction_;
}
inline float C_SKILL::direction() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SKILL.direction)
  return _internal_direction();
}
inline void C_SKILL::_internal_set_direction(float value) {
  
  direction_ = value;
}
inline void C_SKILL::set_direction(float value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SKILL.direction)
}

// -------------------------------------------------------------------

// S_SKILL

// uint64 caster_id = 1;
inline void S_SKILL::clear_caster_id() {
  caster_id_ = uint64_t{0u};
}
inline uint64_t S_SKILL::_internal_caster_id() const {
  return caster_id_;
}
inline uint64_t S_SKILL::caster_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SKILL.caster_id)
  return _internal_caster_id();
}
inline void S_SKILL::_internal_set_caster_id(uint64_t value) {
  
  caster_id_ = value;
}
inline void S_SKILL::set_caster_id(uint64_t value) {
  _internal_set_caster_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SKILL.caster_id)
}

// .Protocol.SkillID skill_id = 2;
inline void S_SKILL::clear_skill_id() {
  skill_id_ = 0;
}
inline ::Protocol::SkillID S_SKILL::_internal_skill_id() const {
  return static_cast< ::Protocol::SkillID >(skill_id_);
}
inline ::Protocol::SkillID S_SKILL::skill_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SKILL.skill_id)
  return _internal_skill_id();
}
inline void S_SKILL::_internal_set_skill_id(::Protocol::SkillID value) {
  
  skill_id_ = value;
}
inline void S_SKILL::set_skill_id(::Protocol::SkillID value) {
  _internal_set_skill_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SKILL.skill_id)
}

// repeated .Protocol.SkillHitResult hit_results = 3;
inline int S_SKILL::_internal_hit_results_size() const {
  return hit_results_.size();
}
inline int S_SKILL::hit_results_size() const {
  return _internal_hit_results_size();
}
inline ::Protocol::SkillHitResult* S_SKILL::mutable_hit_results(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SKILL.hit_results)
  return hit_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::SkillHitResult >*
S_SKILL::mutable_hit_results() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SKILL.hit_results)
  return &hit_results_;
}
inline const ::Protocol::SkillHitResult& S_SKILL::_internal_hit_results(int index) const {
  return hit_results_.Get(index);
}
inline const ::Protocol::SkillHitResult& S_SKILL::hit_results(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SKILL.hit_results)
  return _internal_hit_results(index);
}
inline ::Protocol::SkillHitResult* S_SKILL::_internal_add_hit_results() {
  return hit_results_.Add();
}
inline ::Protocol::SkillHitResult* S_SKILL::add_hit_results() {
  ::Protocol::SkillHitResult* _add = _internal_add_hit_results();
  // @@protoc_insertion_point(field_add:Protocol.S_SKILL.hit_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::SkillHitResult >&
S_SKILL::hit_results() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SKILL.hit_results)
  return hit_results_;
}

// -------------------------------------------------------------------

// C_GAINEXP

// -------------------------------------------------------------------

// S_GAINEXP

// .Protocol.ObjectInfo objectinfo = 1;
inline bool S_GAINEXP::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool S_GAINEXP::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& S_GAINEXP::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_GAINEXP::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_GAINEXP.objectinfo)
  return _internal_objectinfo();
}
inline void S_GAINEXP::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_GAINEXP.objectinfo)
}
inline ::Protocol::ObjectInfo* S_GAINEXP::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_GAINEXP::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_GAINEXP.objectinfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_GAINEXP::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* S_GAINEXP::mutable_objectinfo() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_objectinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_GAINEXP.objectinfo)
  return _msg;
}
inline void S_GAINEXP::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_GAINEXP.objectinfo)
}

// -------------------------------------------------------------------

// S_GAINGOLD

// .Protocol.ObjectInfo objectinfo = 1;
inline bool S_GAINGOLD::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool S_GAINGOLD::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& S_GAINGOLD::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_GAINGOLD::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_GAINGOLD.objectinfo)
  return _internal_objectinfo();
}
inline void S_GAINGOLD::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_GAINGOLD.objectinfo)
}
inline ::Protocol::ObjectInfo* S_GAINGOLD::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_GAINGOLD::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_GAINGOLD.objectinfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_GAINGOLD::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* S_GAINGOLD::mutable_objectinfo() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_objectinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_GAINGOLD.objectinfo)
  return _msg;
}
inline void S_GAINGOLD::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_GAINGOLD.objectinfo)
}

// -------------------------------------------------------------------

// C_PING

// uint64 timestamp = 1;
inline void C_PING::clear_timestamp() {
  timestamp_ = uint64_t{0u};
}
inline uint64_t C_PING::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t C_PING::timestamp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PING.timestamp)
  return _internal_timestamp();
}
inline void C_PING::_internal_set_timestamp(uint64_t value) {
  
  timestamp_ = value;
}
inline void C_PING::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PING.timestamp)
}

// -------------------------------------------------------------------

// S_PING

// uint64 timestamp = 1;
inline void S_PING::clear_timestamp() {
  timestamp_ = uint64_t{0u};
}
inline uint64_t S_PING::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t S_PING::timestamp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PING.timestamp)
  return _internal_timestamp();
}
inline void S_PING::_internal_set_timestamp(uint64_t value) {
  
  timestamp_ = value;
}
inline void S_PING::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PING.timestamp)
}

// -------------------------------------------------------------------

// C_DUNJEON

// -------------------------------------------------------------------

// S_DUNJEON

// uint64 remaintime = 1;
inline void S_DUNJEON::clear_remaintime() {
  remaintime_ = uint64_t{0u};
}
inline uint64_t S_DUNJEON::_internal_remaintime() const {
  return remaintime_;
}
inline uint64_t S_DUNJEON::remaintime() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DUNJEON.remaintime)
  return _internal_remaintime();
}
inline void S_DUNJEON::_internal_set_remaintime(uint64_t value) {
  
  remaintime_ = value;
}
inline void S_DUNJEON::set_remaintime(uint64_t value) {
  _internal_set_remaintime(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DUNJEON.remaintime)
}

// float progress = 2;
inline void S_DUNJEON::clear_progress() {
  progress_ = 0;
}
inline float S_DUNJEON::_internal_progress() const {
  return progress_;
}
inline float S_DUNJEON::progress() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DUNJEON.progress)
  return _internal_progress();
}
inline void S_DUNJEON::_internal_set_progress(float value) {
  
  progress_ = value;
}
inline void S_DUNJEON::set_progress(float value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DUNJEON.progress)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
